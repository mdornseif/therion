/**
 * @file thmpost.cxx
 *
 * THIS FILE IS GENERATED AUTOMATICALLY, DO NOT MODIFY IT !!!
 */  
 
#include "thmpost.h"

#ifndef THMSVC

const char * thmpost_library = 
"%% therion source code\n"
"%%\n"
"%% therion.mp\n"
"%%\n"
"%% This file defines low-level MetaPost macros and variables required\n"
"%% for generation of map symbols\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: therion.mp,v $\n"
"%% $Revision: 1.3 $\n"
"%%\n"
"%% Copyright (C) 2000-2003 Martin Budaj\n"
"%%\n"
"%% Some macros are adapted from MPATTERN package of P. Bolek\n"
"%%\n"
"%% Some macros are used from MetaFun package of H. Hagen\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"%    This file defines low level macros used for map signatures in Therion.\n"
"%    Before loading this file set `Scale' variable to numeric value\n"
"%    representing denominator of the scale ratio. Internal variable \n"
"%    `prologues' is set to 1 by this file. This module loads also \n"
"%    symbol libraries.\n"
"\n"
"\n"
"tracingstats:=1;\n"
"prologues:=1;\n"
"\n"
"if known Background: background:=Background fi;\n"
"%TrueScale:=Scale;\n"
"\n"
"% @VARIABLE\n"
"% symbol_scale --\n"
"%\n"
"% <I>internal numeric</I>; in map symbol definitions used for scaling\n"
"% in <A HREF=\"#T\">T</A> transformation; recommended\n"
"% values are 1 or 2.\n"
"\n"
"%newinternal symbol_scale;\n"
"%symbol_scale := 1;\n"
"\n"
"% @VARIABLE\n"
"% fill_only --\n"
"%\n"
"% <I>boolean</I>, used in <A HREF=\"#thdraw\">thdraw</A> and\n"
"% <A HREF=\"#thpattfill\">thpattfill</A> commands. When set to false, it has \n"
"% no effect, when it is true, it supresses all drawing \n"
"% commands with exception of <I>thpermanentfill</I>, so that only filled \n"
"% areas are drawn\n"
"\n"
"boolean fill_only, horiz_labels, transparency;\n"
"fill_only := false;\n"
"horiz_labels:=true;\n"
"transparency:=false;\n"
"\n"
"string ATTR__id, ATTR__survey, ATTR__scrap;\n"
"boolean ATTR__scrap_centerline;\n"
"picture ATTR__text;\n"
"ATTR__scrap_centerline := false;\n"
"\n"
"color label_fill_color, label_fill_color_tmp;\n"
"label_fill_color := (1.0, 1.0, 1.0);\n"
"def push_label_fill_color(expr r,g,b) =\n"
"  label_fill_color_tmp := label_fill_color;\n"
"  label_fill_color := (r,g,b);\n"
"enddef;\n"
"def pop_label_fill_color =\n"
"  label_fill_color := label_fill_color_tmp;\n"
"enddef;\n"
"def process_filledlabel(expr cent, rot) =\n"
"  begingroup\n"
"    bboxmargin:=2.0bp;\n"
"    q:=((bbox lab) smoothed 2) rotatedaround (cent, rot);\n"
"    fill q withcolor label_fill_color;\n"
"    draw lab rotatedaround (cent, rot);\n"
"    write_circ_bbox(q);  % without corners smoothing it was enough to use\n"
"                         % write_bbox(q);\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"\n"
"numeric area_border_errors;\n"
"area_border_errors = 0;\n"
"\n"
"% @VARIABLE\n"
"% last_write --\n"
"%\n"
"% <I>numeric</I>; charcode of last figure which contained \n"
"% <A HREF=\"#write_bbox\">write_bbox</A> macro; this value is used by\n"
"% <A HREF=\"#close_file\">close_file</A> macro. Initially set to -1.\n"
"\n"
"numeric last_write;\n"
"last_write = -1;\n"
"\n"
"% @VARIABLE\n"
"% strut_string --\n"
"%\n"
"% <I>string</I> containing combination of the \"highest\" and \"lowest\" character\n"
"% in used font; it's used by <A HREF=\"\">free_text</A> macro.\n"
"\n"
"%string strut_string;\n"
"%strut_string = \"(È\";\n"
"\n"
"% @VARIABLE\n"
"% file_name --\n"
"%\n"
"% <I>string</I>, name of file, where <I>write_bbox</I> macro writes\n"
"% text clipping path\n"
"\n"
"% @VARIABLE\n"
"% s ch --\n"
"%\n"
"% <I>string</I>, temporary string/char variables\n"
"\n"
"string s, ch, file_name, bg_name, clip_name, lang, diff_pos, diff_neg,\n"
"     current_scrap, current_src;\n"
"\n"
"% @VARIABLE\n"
"% u v w --\n"
"%\n"
"% <I>internal numeric variables</I> used as basic length units for drawing;\n"
"% they are set by <A HREF=\"#initialize\">initialize</A> macro.\n"
"% <UL> <LI><I>u</I> -- normal unit decreasing with increasing scale\n"
"%      <LI><I>v</I> -- like <I>u</I>, but can increase drammaticaly\n"
"%            when some limit is encountered (to get effects like logarithmic\n"
"%            scale)\n"
"%      <LI><I>w</I> -- nearly constant at all scales\n"
"% </UL>\n"
"\n"
"% @VARIABLE\n"
"% legend_scale --\n"
"%\n"
"% <I>numeric</I>, length of the longer side of signatures' legend box\n"
"\n"
"newinternal legend_scale, u,v,w;\n"
"\n"
"% @VARIABLE\n"
"% lab Lab --\n"
"%\n"
"% <I>picture</I>, in which are saved typeset labels\n"
"\n"
"picture lab, Lab;\n"
"\n"
"% @VARIABLE\n"
"% T --\n"
"%\n"
"% <I>transformation</I>, defines transformation function for transforming \n"
"% every argument of <A HREF=\"#thdraw>thdraw</A> and <A HREF=\"#thfill>thfill</A>\n"
"% macros\n"
"\n"
"transform T;\n"
"\n"
"% @VARIABLE\n"
"% p,q --\n"
"%\n"
"% <I>path</I>, for saving temporary paths\n"
"\n"
"path p,q;\n"
"\n"
"% @MACRO\n"
"% initialize --\n"
"%\n"
"% initializes basic length units <A HREF=\"#u\">(u,v,w)</A> and pens used \n"
"% in map symbols according to scale. Five circular pens are defined:\n"
"% <UL><LI>PenA -- thick; for outlines\n"
"%    <LI>PenB, PenC -- thinner; for pits, symbols etc.\n"
"%    <LI>PenD -- thinnest; for fine details\n"
"%    <LI>PenX -- extra thick; not recommended for use\n"
"% </UL>\n"
"\n"
"def fonts_setup (expr t,s,m,l,h) =\n"
"  write \"\\def\\updown#1#2{\\vbox{\" &\n"
"        \"\\offinterlineskip\" &\n"
"        \"\\setbox100=\\hbox{#1}\" &\n"
"        \"\\setbox101=\\hbox{#2}\" &\n"
"        \"\\ifnum\\wd100>\\wd101\\hsize=\\wd100\\else\\hsize=\\wd101\\fi\" &\n"
"        \"\\centerline{\\box100}\\vskip4pt\" &\n"
"        \"\\centerline{\\box101}}}\" &\n"
"        \"\\def\\thlabel{\\thnormalsize}\" &\n"
"        \"\\def\\thremark{\\thsmallsize\\si}\" &\n"
"        \"\\def\\thcomment{\\thsmallsize}\" &\n"
"        \"\\def\\thentrance{\\thsmallsize}\" &\n"
"        \"\\def\\thaltitude{\\thsmallsize}\" &\n"
"        \"\\def\\thstationname{\\thsmallsize}\" &\n"
"        \"\\def\\thdate{\\thsmallsize}\" &\n"
"        \"\\def\\thheight{\\thsmallsize}\" &\n"
"        \"\\def\\thheightpos{+\\ignorespaces}\" &\n"
"        \"\\def\\thheightneg{-\\ignorespaces}\" &\n"
"        \"\\def\\thframed{\\thsmallsize}\" &\n"
"        \"\\def\\thwallaltitude{\\thtinysize}\"\n"
"  to \"mptexpre.tex\";\n"
"  write \"\\def\\thtinysize{\\size[\" & decimal max(optical_zoom*t,0) & \"]}\" & \n"
"        \"\\def\\thsmallsize{\\size[\" & decimal max(optical_zoom*s,0) & \"]}\" & \n"
"        \"\\def\\thnormalsize{\\size[\" & decimal max(optical_zoom*m,0) & \"]}\" & \n"
"        \"\\def\\thlargesize{\\size[\" & decimal max(optical_zoom*l,0) & \"]}\" & \n"
"        \"\\def\\thhugesize{\\size[\" & decimal max(optical_zoom*h,0) & \"]}\" \n"
"  to \"mptexpre.tex\";\n"
"  write EOF to \"mptexpre.tex\";\n"
"enddef;\n"
"\n"
"def initialize (expr sc) =\n"
"\n"
"  if unknown BaseScale: BaseScale = sc; fi;\n"
"  optical_zoom := BaseScale/sc;\n"
"\n"
"    if BaseScale <= 1:                   % 1:100\n"
"        u:=14bp; v:=14bp; w:=12bp;\n"
"        fonts_setup(8,10,12,16,24);\n"
"    elseif BaseScale <= 2:               % 1:200\n"
"        u:=12bp; v:=12bp; w:=12bp;\n"
"        fonts_setup(7,8,10,14,20);\n"
"    elseif BaseScale <= 5:               % 1:500\n"
"        u:=10bp; v:=10bp; w:=12bp;\n"
"        fonts_setup(6,7,8,10,14);\n"
"    else:\n"
"        u:=7bp; v:=14bp; w:=10bp;\n"
"        fonts_setup(5,6,7,8,10);\n"
"    fi;\n"
"    \n"
"    u := optical_zoom * u;\n"
"    v := optical_zoom * v;\n"
"    w := optical_zoom * w;\n"
"\n"
"    defaultscale := 0.8 * optical_zoom;\n"
"\n"
"    def PenA = pencircle scaled (u/10) enddef;\n"
"    def PenB = pencircle scaled (0.7*u/10) enddef;\n"
"    def PenC = pencircle scaled (0.5*u/10) enddef;\n"
"    def PenD = pencircle scaled (0.35*u/10) enddef;\n"
"    def PenX = pencircle scaled (1.2*u/10) enddef;\n"
"    \n"
"    legend_scale := 3.14*u;\n"
"enddef;\n"
"\n"
"% macro is expanded, we have to know all dimensions and pens before reading\n"
"% mpattern macros\n"
"\n"
"initialize(Scale);\n"
"\n"
"vardef thTEX primary s =\n"
"  write \"verbatimtex \\input th_enc.tex etex\" to \"mptextmp.mp\";\n"
"  write \"btex \\mainfont \"&s&\" etex\" to \"mptextmp.mp\";\n"
"  write EOF to \"mptextmp.mp\";\n"
"  scantokens \"input mptextmp\"\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% inscale --\n"
"%\n"
"% zooms objects to scale specified in legend_scale variable (used in legend\n"
"% typesetting)\n"
"\n"
"def inscale = \n"
"    xscaled legend_scale yscaled (0.618*legend_scale)\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% draw_legend_box --\n"
"%\n"
"% draws a legend bounding box and resets drawoptions() options \n"
"\n"
"def draw_legend_box =\n"
"    clip currentpicture to unitsquare inscale;\n"
"    drawoptions();\n"
"    pickup PenB;\n"
"    draw unitsquare inscale;\n"
"enddef;\n"
"\n"
"def clean_legend_box =\n"
"  unfill unitsquare inscale;\n"
"enddef;\n"
"\n"
"def legend_point (expr name) =\n"
"%  if substring (2,9) of name = \"station\":\n"
"%    scantokens(name)((0.5,0.5) inscale);\n"
"%  else:\n"
"    scantokens(name)((0.5,0.5) inscale,0,1,(0,0));\n"
"%  fi;\n"
"  draw_legend_box;\n"
"enddef;\n"
"\n"
"def legend_line (expr name) =\n"
"  scantokens(name)((((-0.3,.5)..(.3,.7)..(.5,.3)..{dir 80}(1.3,.9)) inscale) \n"
"                randomized 3mm);\n"
"  draw_legend_box;\n"
"enddef;\n"
"\n"
"% legend_label\n"
"% legend_area\n"
"% legend_random\n"
"\n"
"% @MACRO\n"
"% roundone --\n"
"%\n"
"% rounds <I>numeric value</I> to one decimal point\n"
"\n"
"vardef roundone(expr n) =\n"
"%    round(10*n)/10\n"
"  n\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_label --\n"
"%\n"
"% draws a label saved in <I>lab</I> picture variable and calls \n"
"% <A HREF=\"#write_bbox\">write_bbox</A> macro.\n"
"\n"
"\n"
"def process_label (expr cent, rot) =\n"
"  begingroup\n"
"    bboxmargin:=0.8bp;\n"
"    q:=((bbox lab) smoothed 2) rotatedaround (cent, rot);\n"
"    draw lab rotatedaround (cent, rot);\n"
"    write_circ_bbox(q);  % without corners smoothing it was enough to use\n"
"                         % write_bbox(q);\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_uplabel --\n"
"%\n"
"% draws a label into semicircular box and writes clipping path to a file\n"
"\n"
"def process_uplabel =\n"
"    q:=bbox lab;\n"
"    alef:=.8-.02*(xpart lrcorner q - xpart llcorner q);\n"
"%    show alef;\n"
"    q:=alef[llcorner q,ulcorner q]{up} .. {down}alef[lrcorner q, urcorner q] --\n"
"        lrcorner q -- llcorner q -- cycle;\n"
"    draw lab;\n"
"    draw q;\n"
"    q:=reverse q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_downlabel --\n"
"%\n"
"% draws a label into down oriented semicircular box and writes\n"
"% clipping path to a file\n"
"\n"
"def process_downlabel =\n"
"    q:=bbox lab;\n"
"    alef:=1-(.8-.02*(xpart lrcorner q - xpart llcorner q));\n"
"    q:=alef[llcorner q,ulcorner q]{down} .. \n"
"        {up}alef[lrcorner q, urcorner q] --\n"
"        urcorner q -- ulcorner q -- cycle;\n"
"    draw lab;\n"
"    draw q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_updownlabel --\n"
"%\n"
"% draws a label splitted into down and up oriented semicircular boxes and \n"
"% writes clipping path to a file\n"
"\n"
"def process_updownlabel =\n"
"    p:=bbox lab;\n"
"    leftside:=xpart llcorner p;\n"
"    rightside:=xpart lrcorner p;\n"
"    draw (xpart llcorner p,.5[ypart llcorner p,ypart ulcorner p]) -- \n"
"         (xpart lrcorner p,.5[ypart llcorner p,ypart ulcorner p]);\n"
"    alef:=1.05-.02*(xpart lrcorner p - xpart llcorner p);\n"
"%    alef:=.8-.02*(rightside-leftside);\n"
"    p:=alef[(leftside, ypart llcorner p),(leftside, ypart ulcorner p)]{up} .. \n"
"       {down}alef[(rightside, ypart lrcorner p), (rightside, ypart urcorner p)]\n"
"        -- alef[(rightside, ypart urcorner p), (rightside, ypart lrcorner p)]{down}\n"
"        .. {up}alef[(leftside, ypart ulcorner p),(leftside, ypart llcorner p)]\n"
"        -- cycle;\n"
"%    p:=alef[llcorner p,ulcorner p]{up} .. {down}alef[lrcorner p, urcorner p] --\n"
"%        aleff[llcorner p,ulcorner p]{down} .. \n"
"%        {up}aleff[lrcorner p, urcorner p] -- cycle;\n"
"    draw lab;\n"
"    draw p;\n"
"    p:=reverse p;\n"
"    write_circ_bbox(p);\n"
"enddef;\n"
"\n"
"def process_updownlabel_OLD =\n"
"    p:=bbox lab;\n"
"    q:=bbox Lab;\n"
"    leftside:=min(xpart llcorner p, xpart ulcorner q);\n"
"    rightside:=max(xpart lrcorner p, xpart urcorner q);\n"
"    draw .5[(leftside, ypart llcorner p),(leftside, ypart ulcorner q)] -- \n"
"         .5[(rightside,ypart lrcorner p),(rightside,ypart urcorner q)];\n"
"    alef:=.8-.02*(rightside-leftside);\n"
"    q:=alef[(leftside, ypart llcorner p),(leftside, ypart ulcorner p)]{up} .. \n"
"       {down}alef[(rightside, ypart lrcorner p), (rightside, ypart urcorner p)]\n"
"        -- alef[(rightside, ypart urcorner q), (rightside, ypart lrcorner q)]{down}\n"
"        .. {up}alef[(leftside, ypart ulcorner q),(leftside, ypart llcorner q)]\n"
"        -- cycle;\n"
"    draw lab;\n"
"    draw Lab;\n"
"    draw q;\n"
"    q:=reverse q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_boxedlabel --\n"
"%\n"
"% draws a label into circular box and writes\n"
"% clipping path to a file\n"
"\n"
"def process_boxedlabel =\n"
"    q:=bbox lab;\n"
"    draw lab;\n"
"    draw q;\n"
"    write_bbox(q);\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% process_circledlabel --\n"
"%\n"
"% draws a label into circular box and writes\n"
"% clipping path to a file\n"
"\n"
"def process_circledlabel =\n"
"    q:=bbox lab;\n"
"    q:=point 0 of q .. point 1 of q .. point 2 of q .. point 3 of q .. cycle;\n"
"    draw lab;\n"
"    draw q;\n"
"    write_circ_bbox(q);\n"
"enddef;\n"
"\n"
"\n"
"% @MACRO\n"
"% write_bbox --\n"
"%\n"
"% Arguments:\n"
"%   <I>path</I> variable -- rectangular bounding box of a label;\n"
"%   assumptions: path is cyclic, counterclockwise oriented, with four points,\n"
"%   composed from linear segments;\n"
"%   see general <A HREF=\"#write_circ_bbox\">write_circ_bbox</A> macro\n"
"% Results:\n"
"%   one file per figure which uses labels with a clipping path in pseudo-pdf \n"
"%   format\n"
"\n"
"def write_bbox (expr q) =\n"
"    file_name := jobname & \".\" & decimal(charcode) & \"bbox\";\n"
"    for i:=4 downto 0:\n"
"        s  :=  decimal(roundone(xpart point i of q)) & \" \" \n"
"             & decimal(roundone(ypart point i of q)) \n"
"             & if i=4: \" m \" else: \" l\" fi;\n"
"        write s to file_name;\n"
"    endfor;\n"
"    last_write := charcode;\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% write_circ_bbox --\n"
"%\n"
"% Arguments:\n"
"%   <I>path</I> variable, only assumption is that <I>path</I> is cyclic\n"
"%   and counterclockwise oriented.\n"
"% Results:\n"
"%   one file per figure which uses labels with a clipping path in pseudo-pdf \n"
"%   format\n"
"\n"
"def write_circ_bbox expr q =\n"
"    file_name := jobname & \".\" & decimal(charcode) & \"bbox\";\n"
"    tmp:=length q;\n"
"    s :=  decimal(roundone(xpart point tmp of q)) & \" \" \n"
"             & decimal(roundone(ypart point tmp of q)) & \" m\";\n"
"    write s to file_name;\n"
"    for i:=tmp downto 1:\n"
"        s :=  decimal(roundone(xpart precontrol i of q)) & \" \" \n"
"             & decimal(roundone(ypart precontrol i of q)) & \" \"\n"
"             & decimal(roundone(xpart postcontrol i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart postcontrol i-1 of q)) & \" \"\n"
"             & decimal(roundone(xpart point i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart point i-1 of q)) & \" c\";\n"
"        write s to file_name;\n"
"    endfor;\n"
"    last_write := charcode;\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% close_file --\n"
"%\n"
"% closes file with a clipping path; it's invoked by <I>endchar</I> macro\n"
"\n"
"def close_file =\n"
"    if last_write=charcode:\n"
"        write EOF to jobname & \".\" & decimal(charcode) & \"bbox\";\n"
"    fi;\n"
"enddef;\n"
"\n"
"% endchar should run close_file macro\n"
"\n"
"extra_endfig := \"close_file;\";\n"
"\n"
"% @MACRO\n"
"% thdraw --\n"
"%\n"
"% like plain MetaPost's <I>draw</I>, but draws a <I>path</I> transformed\n"
"% (rotated, scaled, shifted) to scrap's coordinates according T variable.\n"
"% (If <I>fill_only=false</I>)\n"
"\n"
"def thdrawoptions(text t) =\n"
"  def _thop_ = t enddef\n"
"enddef;\n"
"thdrawoptions();\n"
"\n"
"def thdraw expr p = \n"
"  if not fill_only:\n"
"    addto currentpicture doublepath (p transformed T) withpen currentpen _thop_ _op_\n"
"  else:\n"
"    addto currentpicture also nullpicture\n"
"  fi\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% thfill --\n"
"%\n"
"% fills a <I>path</I> transformed\n"
"% (rotated, scaled, shifted) to scrap's coordinates according T variable.\n"
"% Filled areas are clipped (like most \n"
"% other lines and points) with a clipping path around text labels.\n"
"\n"
"\n"
"def thfill expr c = \n"
"    addto currentpicture contour (c transformed T) _thop_ _op_ \n"
"enddef;\n"
"\n"
"def thfilldraw expr c =\n"
"  if not fill_only:\n"
"    addto currentpicture contour (c transformed T) withpen currentpen _thop_ _op_ \n"
"  else:\n"
"    addto currentpicture contour (c transformed T) _thop_ _op_ \n"
"  fi\n"
"enddef;\n"
"\n"
"def thunfill expr c = \n"
"    thfill c withcolor background \n"
"enddef;\n"
"\n"
"def thundraw expr p = \n"
"    thdraw p withcolor background \n"
"enddef;\n"
"\n"
"def thunfilldraw expr c = \n"
"    thfilldraw c withcolor background \n"
"enddef;\n"
"\n"
"def thclean expr c =\n"
"  if transparency:\n"
"    thfill c withtransparentcolor tr_bg\n"
"  else:\n"
"    thunfill c\n"
"  fi;\n"
"enddef;\n"
"\n"
"def thPatternFill (expr Path, Pattern) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern Pattern;\n"
"enddef;\n"
"\n"
"%def thLegendPatternFill (expr Path, Pattern) =\n"
"%  T:=identity;\n"
"%  thfill Path withpattern Pattern;\n"
"%enddef;\n"
"\n"
"% for drawarrow:\n"
"\n"
"def _finarr text t =\n"
"  thdraw _apth t;\n"
"  thfilldraw arrowhead _apth  t\n"
"enddef;\n"
"\n"
"% @MACRO\n"
"% thpermanentfill --\n"
"%\n"
"% Fills specified area with a solid color; this area is not affected by \n"
"% text clipping path\n"
"\n"
"%def thpermanentfill expr c = \n"
"%    addto currentpicture contour (c transformed T) _thop_ _op_\n"
"%enddef;\n"
"\n"
"let thpermanentfill = thfill;\n"
"\n"
"\n"
"primarydef p aligned al=\n"
"  p shifted (xpart al * xpart U, ypart al * ypart U)\n"
"enddef;\n"
"\n"
"% macros for drawing scraps in upper and lower levels; filled lower scraps \n"
"% require special treatment (MetaPost doesn't support non-continuous paths).\n"
"% We can't use one file for both, while PDF XObject has to be explicitely \n"
"% filled or stroked. Second macro writes also pseudo-pdf code of a clipping \n"
"% path for given scrap\n"
"\n"
"boolean drawnext;\n"
"drawnext:=true;\n"
"\n"
"def draw_upscrap (expr isout)(text t) =\n"
"  path q;\n"
"  for i=t:\n"
"    if (numeric i):\n"
"      if (i=1): drawnext:=true; else: drawnext:=false; fi;\n"
"    else:\n"
"      if drawnext: draw i withpen PenD; fi;\n"
"      if not known q: q:=i; else: q:=q -- i; fi;\n"
"    fi;\n"
"  endfor;\n"
"  if not cycle q: q:=q -- cycle; fi;\n"
"  if turningnumber q = 0: \n"
"      thwarning(\"scrap outline intersects itself\"); \n"
"  fi;\n"
"  if isout=1:\n"
"    if turningnumber q > 0: q := reverse q; fi;\n"
"  else:\n"
"    if turningnumber q < 0: q := reverse q; fi;\n"
"  fi;\n"
"  addto bgfill contour q;\n"
"enddef;\n"
"\n"
"% following macro writes noncontinuous PostScript path directly to EPS file\n"
"% (filled background and clipping path)\n"
"\n"
"picture bgfill;\n"
"bgfill:=nullpicture;\n"
"\n"
"def draw_downscrap =\n"
"  bg_name := jobname & \".\" & decimal(charcode) & \"bg\";\n"
"  clip_name := jobname & \".\" & decimal(charcode) & \"clip\";\n"
"  write \"%!PS\" to bg_name;\n"
"  write \"%%BoundingBox: \" & \n"
"     decimal round xpart llcorner bgfill & \" \" &\n"
"     decimal round ypart llcorner bgfill & \" \" &\n"
"     decimal round xpart urcorner bgfill & \" \" &\n"
"     decimal round ypart urcorner bgfill \n"
"     to bg_name;\n"
"  write \"%%Page: 1 1\" to bg_name;\n"
"  write \"newpath\" to bg_name;\n"
"  for qq within bgfill:\n"
"    q := pathpart qq;\n"
"    tmp:=length q;\n"
"    s := decimal(roundone(xpart point tmp of q)) & \" \" \n"
"             & decimal(roundone(ypart point tmp of q)) & \" m\";\n"
"    write s & \"oveto\" to bg_name;\n"
"    write s to clip_name;\n"
"    for i:=tmp downto 1:\n"
"        s :=  decimal(roundone(xpart precontrol i of q)) & \" \" \n"
"             & decimal(roundone(ypart precontrol i of q)) & \" \"\n"
"             & decimal(roundone(xpart postcontrol i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart postcontrol i-1 of q)) & \" \"\n"
"             & decimal(roundone(xpart point i-1 of q)) & \" \" \n"
"             & decimal(roundone(ypart point i-1 of q)) & \" c\";\n"
"        write s & \"urveto\" to bg_name;\n"
"        write s to clip_name;\n"
"    endfor;\n"
"  endfor;\n"
"  write \"closepath fill\" to bg_name;\n"
"  write \"showpage\" to bg_name;\n"
"  write \"%%EOF\" to bg_name;\n"
"  write EOF to bg_name;\n"
"  write EOF to clip_name;\n"
"  bgfill:=nullpicture;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"vardef buildcycle(text ll) =\n"
"  save ta_, tb_, k_, i_, pp_; path pp_[];\n"
"  k_=0;\n"
"  for q=ll: pp_[incr k_]=q; endfor\n"
"  i_=k_;\n"
"  for i=1 upto k_:\n"
"    (ta_[i], length pp_[i_]-tb_[i_]) =\n"
"      pp_[i] intersectiontimes reverse pp_[i_];\n"
"    if ta_[i]<0:\n"
"      message(\"[Error: area borders \"& area_border[i] &\" and \"& \n"
"         area_border[i_] &\" don't intersect in scrap \" & current_scrap &\n"
"         \" (file \" & current_src & \")]\");\n"
"      area_border_errors := area_border_errors + 1;\n"
"    fi\n"
"    i_ := i;\n"
"  endfor\n"
"  for i=1 upto k_: subpath (ta_[i],tb_[i]) of pp_[i] .. endfor\n"
"    cycle\n"
"enddef;\n"
"\n"
"vardef unitvector primary z = \n"
"  if (z<>(0,0)):\n"
"    z/abs z \n"
"  else:\n"
"    hide(thwarning(\"strange path\"))\n"
"    (0,epsilon)\n"
"  fi\n"
"enddef;\n"
"\n"
"def thwarning (expr m) = \n"
"  message(\"[Warning: \" & m & \" in scrap \" & current_scrap & \"]\");\n"
"enddef;\n"
"\n"
"def check_area_borders = \n"
"  if area_border_errors > 0:\n"
"  fi;\n"
"enddef;\n"
"\n"
"%%%%%%%%%%%% Map symbols management %%%%%%%%%%%%%%%%%%%\n"
"\n"
"def mapsymbol (expr name, set, warning) = \n"
"  string s, stype, lname, ID;\n"
"  stype = substring (0,1) of name;\n"
"  lname = name & \"_\" & set;\n"
"  ID := \"ID_\" & lname;\n"
"  if (known scantokens ID):\n"
"    if stype = \"a\":\n"
"      s = \"def \" & name & \" = scantokens(\" & ditto & lname & ditto & \") enddef;\";\n"
"    else:\n"
"      s = \"let \" & name & \" = \" & lname & \";\";\n"
"    fi;\n"
"    scantokens s;\n"
"  elseif warning:  \n"
"    message(\"[Warning: undefined symbol `\" & lname & \"']\");\n"
"  fi;\n"
"enddef;\n"
"\n"
"%def hidesymbol (expr name) =\n"
"%  string s, stype;\n"
"%  stype = substring (0,1) of name;\n"
"%  if stype = \"a\":\n"
"%    s = \"def \" & name & \" = scantokens(\" & ditto & \"a_empty\" & ditto & \") enddef;\";\n"
"%  else:\n"
"%    s = \"vardef \" & name & \"@# (text t) = enddef;\";\n"
"%  fi;\n"
"%  scantokens s;\n"
"%  write name to \"missed.dat\";\n"
"%enddef;\n"
"\n"
"def initsymbol (expr name) =\n"
"  s := \"ID_\" & name & \" = 1\";\n"
"  scantokens s;\n"
"enddef;\n"
"\n"
"%%%\n"
"\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% P. Bolek's MPATTERN package adapted and simplified for Therion\n"
"% (with the same user interface except of patterncolor)\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"string Pname_, PXYsteps_;\n"
"string Pmatrix_;\n"
"\n"
"numeric Pnum_; Pnum_=0;\n"
"\n"
"def PmakeBB_=\n"
"   PBBox_ := \"[\" & decimal Plft_ & \" \" & decimal Plow_ & \" \"\n"
"   & decimal Prt_ & \" \" & decimal Pup_ & \"]\";\n"
"enddef;\n"
"\n"
"def Psteps_=\n"
"   PXYsteps_ := decimal\n"
"     if unknown PXStep_: (Prt_-Plft_) else: PXStep_ fi \n"
"   & \":\" & decimal\n"
"     if unknown PYStep_: (Pup_-Plow_) else: PYStep_ fi;\n"
"enddef;\n"
"   \n"
"vardef Pfindbounds_=\n"
"   Plow_ = ypart (llcorner currentpicture);\n"
"   Plft_ = xpart (llcorner currentpicture);\n"
"   Pup_ = ypart (urcorner currentpicture);\n"
"   Prt_ = xpart (urcorner currentpicture);\n"
"   PmakeBB_;\n"
"enddef;\n"
"\n"
"def PmakePattern_(expr name)=\n"
"  write decimal (Pnum_*epsilon) & \":\"\n"
"    & jobname & \".\" & decimal charcode & \":\"\n"
"    & PBBox_ & \":\"\n"
"    & PXYsteps_ & \":\"\n"
"    & Pmatrix_ \n"
"  to \"patterns.dat\"\n"
"enddef;\n"
"\n"
"% User interface macros\n"
"\n"
"vardef patternbbox(expr a)(text b)=\n"
"   save Pi_, Pz_;\n"
"   numeric Pi_, Pz_[];\n"
"   if pair a:\n"
"      Plft_:=min(xpart(a),xpart(b)); Plow_:=min(ypart(a),ypart(b));\n"
"      Prt_:=max(xpart(a),xpart(b));  Pup_:=max(ypart(a),ypart(b));\n"
"   else:\n"
"      Pi_=1;\n"
"      for t=b:\n"
"\t Pz_[Pi_]=t;\n"
"\t Pi_:=Pi_+1;\n"
"      endfor;\n"
"      Plft_:=min(a,Pz_2);   Plow_:=min(Pz_1,Pz_3);\n"
"      Prt_:=max(a,Pz_2); Pup_:=max(Pz_1,Pz_3);\n"
"   fi;\n"
"   PmakeBB_;\n"
"enddef;\n"
"\n"
"def beginpattern(suffix name)=\n"
"  numeric PXStep_, PYStep_;\n"
"  numeric Plow_, Plft_, Pup_, Prt_;\n"
"  string PBBox_;\n"
"  Pmatrix_:=\"[1 0 0 1 0 0]\";\n"
"  Pname_:=str name;\n"
"  Pnum_:=Pnum_+1;\n"
"  beginfig(Pnum_+4000);\n"
"enddef;\n"
"\n"
"def endpattern=\n"
"  if unknown PBBox_:\n"
"     Pfindbounds_;\n"
"  fi;\n"
"  endfig;\n"
"  Psteps_;\n"
"  PmakePattern_(Pname_);\n"
"  scantokens(Pname_ & \"=Pnum_;\");\n"
"enddef;\n"
"\n"
"primarydef p withpattern s=\n"
"  if known s:\n"
"    p withcolor (epsilon, 10*epsilon, s*epsilon);\n"
"  else:\n"
"    p withcolor (1,0,0);\n"
"    message(\"Warning: undefined pattern ignored\");\n"
"  fi;  \n"
"enddef;\n"
"   \n"
"def patterntransform expr t=\n"
"   Pmatrix_ := \"[\" & decimal xxpart t\n"
"              & \" \" & decimal yxpart t\n"
"              & \" \" & decimal xypart t\n"
"              & \" \" & decimal yypart t\n"
"              & \" \" & decimal xpart t\n"
"              & \" \" & decimal ypart t & \"]\";\n"
"enddef;\n"
"\n"
"def patternxstep expr t=\n"
"   PXStep_ = t;\n"
"enddef;\n"
"\n"
"def patternystep expr t=\n"
"   PYStep_ = t;\n"
"enddef;\n"
"\n"
"def patternstep text t=\n"
"   if pair t:\n"
"      PXStep_ = xpart t;\n"
"      PYStep_ = ypart t;\n"
"   else:\n"
"      (PXStep_,PYStep_)=t;\n"
"   fi;\n"
"enddef;\n"
"\n"
"def patterncolor expr t=\n"
"  message(\"Warning: patterncolor not supported in Therion\");\n"
"enddef;\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% end of pattern macros\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"% transparent rgb colors\n"
"\n"
"numeric RGBnum; RGBnum=0;\n"
"string RGBname;\n"
"\n"
"def def_transparent_rgb (suffix name)(expr r, g, b) =\n"
"  RGBnum := RGBnum+1;\n"
"  RGBname := str name;\n"
"  write decimal (RGBnum*epsilon) & \":\"\n"
"    & decimal r & \" \"\n"
"    & decimal g & \" \"\n"
"    & decimal b \n"
"  to \"rgbcolors.dat\";\n"
"  scantokens(RGBname & \":=RGBnum;\");\n"
"enddef;\n"
"\n"
"primarydef p withtransparentcolor s=\n"
"   p withcolor (epsilon, 12*epsilon, s*epsilon);\n"
"enddef;\n"
"\n"
"def_transparent_rgb(tr_white, 1, 1, 1);\n"
"def_transparent_rgb(tr_blue, 0, 0, 1);\n"
"def_transparent_rgb(tr_black, 0, 0, 0);\n"
"def_transparent_rgb(tr_bg, \n"
"               redpart background, greenpart background, bluepart background);\n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% some useful macros from H. Hagen's MetaFun package\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"vardef paired (expr d) =\n"
"  if pair d : d else : (d,d) fi\n"
"enddef ;\n"
"\n"
"primarydef p randomshifted s = \n"
"  begingroup ; save ss ; pair ss ; ss := paired(s) ; \n"
"  p shifted (-.5xpart ss + uniformdeviate xpart ss,\n"
"             -.5ypart ss + uniformdeviate ypart ss) \n"
"  endgroup \n"
"enddef ; \n"
"\n"
"primarydef p randomized s =\n"
"  (if path p : \n"
"    for i=0 upto length(p)-1 :\n"
"      ((point       i    of p) randomshifted s) .. controls \n"
"      ((postcontrol i    of p) randomshifted s) and \n"
"      ((precontrol (i+1) of p) randomshifted s) .. \n"
"    endfor \n"
"    if cycle p : \n"
"      cycle \n"
"    else :\n"
"      ((point length(p) of p) randomshifted s) \n"
"    fi\n"
"  elseif pair p :\n"
"    p randomshifted s  \n"
"  elseif color p :\n"
"    if color s : \n"
"      (uniformdeviate redpart   s * redpart   p,\n"
"       uniformdeviate greenpart s * greenpart p,\n"
"       uniformdeviate bluepart  s * bluepart  p)  \n"
"    elseif pair s : \n"
"      ((xpart s + uniformdeviate (ypart s - xpart s)) * p)  \n"
"    else :  \n"
"      (uniformdeviate s * p)  \n"
"    fi \n"
"  else :\n"
"    p + uniformdeviate s  \n"
"  fi)  \n"
"enddef ; \n"
"\n"
"primarydef p llmoved d =\n"
"  ((llcorner p) shifted (-xpart paired(d),-ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p lrmoved d =\n"
"  ((lrcorner p) shifted (+xpart paired(d),-ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p urmoved d =\n"
"  ((urcorner p) shifted (+xpart paired(d),+ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p ulmoved d =\n"
"  ((ulcorner p) shifted (-xpart paired(d),+ypart paired(d)))\n"
"enddef ;\n"
"\n"
"primarydef p smoothed d =\n"
"  (p llmoved (-xpart paired(d),0) -- p lrmoved (-xpart paired(d),0) {right} .. \n"
"   p lrmoved (0,-ypart paired(d)) -- p urmoved (0,-ypart paired(d)) {up}    .. \n"
"   p urmoved (-xpart paired(d),0) -- p ulmoved (-xpart paired(d),0) {left}  ..\n"
"   p ulmoved (0,-ypart paired(d)) -- p llmoved (0,-ypart paired(d)) {down}  .. cycle) \n"
"enddef ;\n"
"\n"
"vardef punked primary p = \n"
"  (point 0 of p for i=1 upto length(p)-1 : -- point i of p endfor \n"
"   if cycle p : -- cycle else : -- point length(p) of p fi)  \n"
"enddef ;  \n"
"\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"% end of MetaFun macros\n"
"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n"
"\n"
"% we input map symbol definitions\n"
"\n"
"\n\n\n%%%%% INPUT thPoint %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for point map symbols\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thPoint.mp,v $\n"
"%% $Revision: 1.8 $\n"
"%%\n"
"%% Copyright (C) 2000-2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"pair U;\n"
"\n"
"def p_stalactite_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u, .4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-.4u) -- (0,.15u) -- (-.15u,.4u);\n"
"    thdraw (0,.15u) -- (.15u,.4u);\n"
"enddef;\n"
"\n"
"def p_stalagmite_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,.4u) -- (0,-.15u) -- (-.15u,-.4u);\n"
"    thdraw (0,-.15u) -- (.15u,-.4u);\n"
"enddef;\n"
"\n"
"def p_pillar_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,.15u)--(0,-.15u);\n"
"    thdraw (-.15u,-.4u)--(0,-.15u)--(.15u,-.4u);\n"
"    thdraw (-.15u,.4u)--(0,.15u)--(.15u,.4u);\n"
"enddef;\n"
"\n"
"def p_curtain_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.15u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.15u,.4u)--(0,.15u)--(.15u,.4u);\n"
"    thdraw (0,.15u)--(0,0){dir 180}..(-.12u,-.11u)..{dir 0}(0,-.22u)--(0,-.4u);\n"
"enddef;\n"
"\n"
"def p_helictite_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.2u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,.4u)--(0,-.4u);\n"
"    p := (-.2u,.4u)---(-.2u,.1u){down}..{dir -10}(-.1u,0.02u)---origin;\n"
"    thdraw p;\n"
"    thdraw p reflectedabout (origin,(0,u)) reflectedabout (origin,(u,0));\n"
"enddef;\n"
"\n"
"def p_sodastraw_UIS(expr pos,theta,sc,al) =\n"
"    U:=(.5u,.25u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,.2u)--(.5u,.2u);\n"
"    pickup PenD;\n"
"    thdraw (-.4u,.2u)--(-.4u,0);\n"
"    thdraw (-.12u,.2u)--(-.12u,-.25u);\n"
"    thdraw (.02u,.2u)--(.02u,-.1u);\n"
"    thdraw (.23u,.2u)--(.23u,-.19u);\n"
"    thdraw (.35u,.2u)--(.35u,-.15u);\n"
"enddef;\n"
"\n"
"def p_crystal_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.35u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := ((-.35*u,0)--(.35*u,0));\n"
"    thdraw p;\n"
"    thdraw p rotated (60);\n"
"    thdraw p rotated (120);\n"
"enddef;\n"
"\n"
"def p_flowstone_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.45u,.1u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := ((-.15*u,0)--(.15*u,0));\n"
"    thdraw p shifted (.3u,-.1u);\n"
"    thdraw p shifted (-.3u,-.1u);\n"
"    thdraw p shifted (0,.1u);\n"
"enddef;\n"
"\n"
"def p_moonmilk_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.2u){up}..{dir -60}(-.18u,-.105u){dir 80}..\n"
"        {dir-80}(.18u,-.105u){dir 60}..{down}(.5u,-.2u);\n"
"enddef;\n"
"\n"
"def p_wallcalcite_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.2u,-.2u)--(0,.1u)--(.2u,-.2u);\n"
"enddef;\n"
"\n"
"def p_popcorn_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.2u)--(.5u,-.2u);\n"
"    pickup PenD;\n"
"    thdraw (-.3u,-.2u)--(-.3u,.1u);\n"
"    thdraw (0,-.2u)--(0,.1u);\n"
"    thdraw (.3u,-.2u)--(.3u,.1u);\n"
"    thfill fullcircle scaled .2u shifted (-.3u,.1u);\n"
"    thfill fullcircle scaled .2u shifted (0,.1u);\n"
"    thfill fullcircle scaled .2u shifted (.3u,.1u);\n"
"enddef;\n"
"\n"
"def p_disk_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.2u,-.3u)--origin--(.2u,-.3u);\n"
"    p:=fullcircle scaled .3u shifted (0,.15u);\n"
"    thclean p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_gypsum_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.25u,.25u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.25u,0)--(.25u,0);\n"
"    thdraw (0,-.25u)--(0,.25u);\n"
"enddef;\n"
"\n"
"def p_aragonite_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.3u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-.4u)--(0,.3u);\n"
"    thdraw (0,-.1u){dir 40}..{dir 5}(.3u,.08u);\n"
"    thdraw (0,-.1u){dir 140}..{dir 175}(-.3u,.08u);\n"
"    thdraw (0,.2u){dir 30}..{dir 5}(.25u,.3u);\n"
"    thdraw (0,.2u){dir 150}..{dir 175}(-.25u,.3u);\n"
"enddef;\n"
"\n"
"\n"
"def p_cavepearl_SKBB (expr pos,theta,sc,al)=\n"
"    U:=(.25u,.25u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=fullcircle scaled .25u shifted (0,.16u);\n"
"    thdraw p;\n"
"    thdraw p rotated 120;\n"
"    thdraw p rotated 240;\n"
"enddef;\n"
"\n"
"def p_gypsumflower_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"%    thdraw (.2u,0){left}..(0,.2u)..(.25u,.35u)..(.5u,0)..\n"
"%        (.1u,-.3u)..{dir 125}(-.5u,.2u);\n"
"    thdraw (.18u,0){left}..(0,.15u)..(.2u,.3u)..(.4u,0)..\n"
"        (.15u,-.28u)..{dir 120}(-.4u,.15u);\n"
"enddef;\n"
"\n"
"def p_rimstonepool_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := (-.4u,.2u){dir -70}..{dir 70}(.4u,.2u);\n"
"    thfill buildcycle(p,((.5u,.1u)--(-.5u,.1u)));\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_rimstonedam_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,.2u){dir -70}..{dir 70}(.4u,.2u);\n"
"enddef;\n"
"\n"
"def p_anastomosis_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(-.4u,-.2u)--(-.3u,-.3u)--(0,.3u)--(.1u,.2u);\n"
"    thdraw p;\n"
"    thdraw p shifted (.3u,0);\n"
"enddef;\n"
"\n"
"def p_karren_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.3u){dir -85}..{dir 85}(-.32u,-.3u)..(-.28u,.3u){dir 85}..\n"
"        {dir -85}(-.12u,.3u)..(-.08u,-.3u){dir-85}..{dir 85}(.08u,-.3u)..\n"
"        {dir85}(.12u,.3u)..(.28u,.3u){dir -85}..(.32u,-.3u){dir -85}..\n"
"        {dir 85}(.5u,-.3u);\n"
"enddef;\n"
"\n"
"def p_scallop_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-.4u){dir 125}..{dir 105}(-.2u,.1u){up}..\n"
"        {down}(.2u,.1u){dir -105}...{dir -125}(0,-.4u);\n"
"enddef;\n"
"\n"
"def p_flute_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,.2u)--(.5u,.2u);\n"
"    thdraw (-.3u,.2u){dir -70}..{dir 70}(.3u,.2u);\n"
"enddef;\n"
"\n"
"def p_raft_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,.2u){dir -80}..(-.3u,-.2u)..origin..(.3u,.2u)..\n"
"        {dir -80}(.5u,-.2u);\n"
"enddef;\n"
"\n"
"def p_raftcone_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.3u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.4u)--(0,.4u)--(.3u,-.4u);\n"
"enddef;\n"
"\n"
"def p_spring_SKBB (expr pos,theta,sc,al)=\n"
"  U:=(.3u,.2u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.3u,.2u){down}..(0,-.2u)..{up}(.3u,.2u);\n"
"enddef;\n"
"\n"
"def p_sink_SKBB (expr pos,theta,sc,al)=\n"
"  U:=(.3u,.2u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.3u,-.2u){up}..(0,.2u)..{down}(.3u,-.2u);\n"
"enddef;\n"
"\n"
"def p_narrowend_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.1u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.1u,-.4u)--(-.1u,.4u);\n"
"    thdraw (.1u,-.4u)--(.1u,.4u);\n"
"enddef;\n"
"\n"
"def p_lowend_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.1u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,-.1u)--(.4u,-.1u);\n"
"    thdraw (-.4u,.1u)--(.4u,.1u);\n"
"enddef;\n"
"\n"
"def p_lowend_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,0);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,0)--(.4u,0);\n"
"enddef;\n"
"\n"
"def p_flowstonechoke_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(-.4u,-.4u){right}..{dir120}(-.2u,-.2u){dir -20}..{up}(0,0);\n"
"    thdraw p;\n"
"    thdraw p shifted (0,.2u);\n"
"    thdraw p reflectedabout (origin,down);\n"
"    thdraw p reflectedabout (origin,down) shifted (0,.2u);\n"
"enddef;\n"
"\n"
"def p_breakdownchoke_NSS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.1u)--(-.15u,.05u)--(-.48u,.2u)--cycle;\n"
"    thdraw (-.2u,-.2u)--(.15u,-.18u)--(-.08u,.14u)--cycle;\n"
"    thdraw (.1u,0)--(.4u,-.1u)--(.5u,.2u)--(.1u,.2u)--cycle;\n"
"enddef;\n"
"\n"
"def p_bedrock_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,0)--(.5u,0);\n"
"    thdraw (-.3u,0)--(-.3u,.2u);\n"
"    thdraw (.3u,0)--(.3u,-.2u);\n"
"enddef;\n"
"\n"
"def p_sand_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.2u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenB;\n"
"    thdraw (0,.2u);\n"
"    thdraw (0,.2u) rotated 120;\n"
"    thdraw (0,.2u) rotated 240;\n"
"enddef;\n"
"\n"
"def p_clay_SKBB (expr pos,theta,sc,al) =\n"
"    U:=(.3u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,0){up}..origin{down}..{up}(0.3u,0);\n"
"enddef;\n"
"\n"
"def p_pebbles_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.45u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=superellipse((.2u,0),(0,.1u),(-.2u,0),(0,.-.1u),.75);\n"
"    thdraw p rotated 20 shifted (0,.25u);\n"
"    thdraw p rotated -37 shifted (.25u,-.25u);\n"
"    thdraw p rotated -62 shifted (-.25u,-.25u);\n"
"enddef;\n"
"\n"
"def p_debris_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.4u)--(0,-.22u)--(-.4u,-.1u)--cycle;\n"
"    thdraw (.2u,-.4u)--(.4u,-.1u)--(.1u,-.1u)--cycle;\n"
"    thdraw (-.1u,0)--(.2u,.3u)--(-.2u,.3u)--cycle;\n"
"enddef;\n"
"\n"
"def p_blocks_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.5u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.5u,-.5u)--(.3u,-.4u)--(-.17u,.2u)--cycle;\n"
"    thdraw (.25u,-.25u)--(.5u,-.15u)--(.3u,.5u)--(-.1u,.5u)--cycle;\n"
"    thdraw (-.27u,0)--(-.1u,.3u)--(-.5u,.35u)--cycle;\n"
"    pickup PenD;\n"
"    thdraw (-.5u,-.5u)--(-.1u,-.2u)--(-.17u,.2u);\n"
"    thdraw (-.1u,-.2u)--(.3u,-.4u);\n"
"    thdraw (.25u,-.25u)--(.3u,0)--(.2u,.2u)--(-.1u,.5u);\n"
"    thdraw (.3u,.5u)--(.2u,.2u);\n"
"    thdraw (.5u,-.15u)--(.3u,0);\n"
"enddef;\n"
"\n"
"def p_water_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.425u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenD;\n"
"    p:=fullcircle xscaled (.85u) yscaled (.6u);\n"
"    thfill p withpattern pattern_water_UIS;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_ice_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := (0,.05u)--(0,.35u);\n"
"    thdraw p;\n"
"    thdraw p shifted (-.25u,-.3u);\n"
"    thdraw p shifted (.25u,-.3u);\n"
"    p := (-0.15u,.2u)--(0.15u,.2u);\n"
"    thdraw p;\n"
"    thdraw p shifted (-.25u,-.3u);\n"
"    thdraw p shifted (.25u,-.3u);\n"
"enddef;\n"
"\n"
"def p_snow_SKBB (expr pos,theta,sc,al)=\n"
"    U:=(.35u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := origin--(0,.25*u);\n"
"    q := ((0,.35u)--(0,0.25u)--(0.1u,0.25u)) rotatedaround ((0,0.25u),45);\n"
"    thdraw p;\n"
"    thdraw p rotated (60);\n"
"    thdraw p rotated (120);\n"
"    thdraw p rotated (180);\n"
"    thdraw p rotated (240);\n"
"    thdraw p rotated (300);\n"
"    thdraw q;\n"
"    thdraw q rotated (60);\n"
"    thdraw q rotated (120);\n"
"    thdraw q rotated (180);\n"
"    thdraw q rotated (240);\n"
"    thdraw q rotated (300);\n"
"enddef;\n"
"\n"
"\n"
"def p_archeomaterial_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p := fullcircle scaled .8u; \n"
"    thdraw (-.5u,-.5u)--origin cutbefore p;\n"
"    thdraw (-.5u,.5u)--origin cutbefore p;\n"
"    thdraw origin--(.4u,0);\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_paleomaterial_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.4u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thfill (-.4u,-.2u)..(-.2u,-.08u)---(-.1u,.05u)---(0,.2u)..(-.03u,.4u)..\n"
"        (.2u,.3u)..(.35u,.25u)..(.2u,.2u)---origin---(-.1u,-.17u)..\n"
"        (-.08u,-.25u){dir -120}..(-.3u,-.23u)\n"
"        ..cycle;\n"
"enddef;\n"
"\n"
"def p_guano_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.4u,.35u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,.2u){dir 40}..{down}(0,-.35u){up}..{dir-40}(.4u,.2u);\n"
"enddef;\n"
"\n"
"def p_vegetabledebris_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.38u,.3u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,-.3u)--(0,.3u);\n"
"    thdraw (0,-.3u)--(.3u,.3u);\n"
"    thdraw (-.25u,.13u)--(.38u,.13u);\n"
"    thdraw (-.38u,-.13u)--(.25u,-.13u);\n"
"enddef;\n"
"\n"
"def p_root_ASF (expr pos,theta,sc,al)=\n"
"    U:=(.1u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.1u,-.5u)--(-.1u,.5u);\n"
"    p:=(-.1u,-.3u)--(.1u,-.5u);\n"
"    thdraw p;\n"
"    thdraw p shifted (0,.2u);\n"
"    thdraw p shifted (0,.4u);\n"
"enddef;\n"
"\n"
"def p_entrance_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thfill (-.2u,-.5u)--(0,.5u)--(.2u,-.5u)--cycle;\n"
"enddef;\n"
"\n"
"def p_waterflow_paleo_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.2u,u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-u)--(0,u);\n"
"    thdraw halfcircle scaled .4u shifted (0,-.4u);\n"
"    p:=(-.15u,.6u)--(0,u)--(.15u,.6u)--cycle;\n"
"    thfill p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_gradient_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.15u,u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (0,-u)--(0,u);\n"
"    p:=(-.15u,.6u)--(0,u)--(.15u,.6u)--cycle;\n"
"    thfill p;\n"
"    thdraw p;\n"
"enddef;\n"
"\n"
"def p_gradient_BCRA (expr pos,theta,sc,al)=\n"
"    U:=(.25u,0.7u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    thfill (-.25u,-0.7u)--(0,.7u)--(.25u,-.7u)--cycle;\n"
"enddef;\n"
"\n"
"% by Philip Schuchardt\n"
"def p_gradient_NSS (expr pos,theta,sc,al) =\n"
"  U:=(.7u, .6u);\n"
"  T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"  pickup PenC;\n"
"\n"
"  thdraw (-.3u, -.5u) -- (-.7u, -.2u);\n"
"  thdraw (-.2u, -.4u) -- (-.4u, .3u);\n"
"  thdraw (0u, -.3u) -- (0u, .6u);\n"
"  thdraw (.3u, -.5u) -- (.7u, -.2u);\n"
"  thdraw (.2u, -.4u) -- (.4u, .3u);\n"
"enddef;\n"
"\n"
"def p_waterflow_permanent_UIS (expr pos,theta,sc,al)=\n"
"    U:=(.15u,.5u);\n"
"    T:=identity aligned al rotated theta scaled sc shifted pos;\n"
"    pickup PenC;\n"
"    p:=(0,.5u){down}..(.12u,.3u)..(-.15u,.15u)..(.13u,0)..\n"
"        (-.08u,-.2u)..{down}(0,-.5u);\n"
"    p:=p rotated 180;\n"
"    thdraw p;\n"
"    thdrawoptions();\n"
"    oldahlength:=ahlength; ahlength:=2.5pt*optical_zoom;\n"
"    thdraw arrowhead p;\n"
"    thfill arrowhead p;\n"
"    ahlength:=oldahlength;\n"
"enddef;\n"
"\n"
"def p_waterflow_intermittent_UIS (expr pos,theta,sc,al)=\n"
"  thdrawoptions(dashed evenly scaled (.5 * optical_zoom));\n"
"  p_waterflow_permanent_UIS (pos,theta,sc,al);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def p_airdraught_UIS (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,u)--(0,-0.75u);\n"
"\tp:=(-.2u,.65u){dir 20}..{dir 90}(0,u);\n"
"\tthdraw p;\n"
"\tthdraw p reflectedabout (origin,(0,u));\n"
"\tfor i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"\t  thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"\tendfor;\n"
"enddef;\n"
"\n"
"def p_airdraught_winter_UIS (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,u)--(0,-0.75u);\n"
"  p:=(-.2u,.65u){dir 20}..{dir 90}(0,u);\n"
"  thdraw p;\n"
"  thdraw p reflectedabout (origin,(0,u));\n"
"  for i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"    thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"  endfor;\n"
"  thclean fullcircle scaled 0.6u shifted (0,0.05u);\n"
"  thdraw (-0.1732u,-0.05u) -- (0.1732u,0.15u);\n"
"  thdraw (0.1732u,-0.05u) -- (-0.1732u,0.15u);\n"
"  thdraw (0,-0.15u) -- (0,0.25u);\n"
"enddef;\n"
"\n"
"def p_airdraught_summer_UIS (expr pos,theta,sc,al)=\n"
"  U:=(.2u,u);\n"
"  T:=identity aligned al rotated theta scaled 1 shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (0,u)--(0,-0.75u);\n"
"  p:=(-.2u,.65u){dir 20}..{dir 90}(0,u);\n"
"  thdraw p;\n"
"  thdraw p reflectedabout (origin,(0,u));\n"
"  for i:=1 upto round(3+2*mlog(sc)/mlog 2):\n"
"    thdraw (0,-(1-0.2i)*u)--(.2u,-(1-0.2(i-1))*u);\n"
"  endfor;\n"
"  thclean fullcircle scaled 0.6u shifted (0,0.05u);\n"
"  thdraw (-0.1732u,-0.05u) -- (0.1732u,0.15u);\n"
"  thdraw (0.1732u,-0.05u) -- (-0.1732u,0.15u);\n"
"  thdraw (0,-0.15u) -- (0,0.25u);\n"
"  thclean fullcircle scaled 0.3u shifted (0,0.05u);\n"
"  thdraw fullcircle scaled 0.2u shifted (0,0.05u);\n"
"enddef;\n"
"\n"
"\n"
"def p_station_fixed_ASF (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    pair z;\n"
"    z:=(0,.2u);\n"
"    thclean z -- (z rotated 120) -- (z rotated 240) -- cycle;\n"
"    thdraw z -- (z rotated 120) -- (z rotated 240) -- cycle;\n"
"    thdraw origin;\n"
"enddef;\n"
"\n"
"def p_station_painted_SKBB (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenC;\n"
"    thclean fullcircle scaled 0.25u;\n"
"    thdraw fullcircle scaled 0.25u;\n"
"enddef;\n"
"\n"
"def p_station_natural_ASF (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    thclean fullcircle scaled .3u;\n"
"    thdraw fullcircle scaled .3u;\n"
"    thdraw origin;\n"
"enddef;\n"
"\n"
"def p_station_temporary_ASF (expr pos)=\n"
"    T:=identity shifted pos;\n"
"    pickup PenD;\n"
"    p:=(-.2u,0)--(.2u,0);\n"
"    thdraw p;\n"
"    thdraw p rotated 90;\n"
"    thclean fullcircle scaled .16u;\n"
"    pickup PenC;\n"
"    thdraw origin;\n"
"enddef;\n"
"\n"
"let p_station_temporary_SKBB = p_station_painted_SKBB;\n"
"\n"
"def p_steps_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,.3u)--(-.3u,.1u)--(-.1u,.1u)--(-.1u,-.1u)--\n"
"           (.1u,-.1u)--(.1u,-.3u)--(.3u,-.3u);\n"
"enddef;\n"
"\n"
"def p_fixedladder_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.15u,-.4u)--(-.15u,.4u);\n"
"    thdraw (.15u,-.4u)--(.15u,.4u);\n"
"    thdraw (-.15u,0)--(.15u,0);\n"
"    thdraw (-.15u,.2u)--(.15u,.2u);\n"
"    thdraw (-.15u,-.2u)--(.15u,-.2u);\n"
"enddef;\n"
"\n"
"def p_ropeladder_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (.1u,-.4u)..(.2u,-.2u)..(.1u,.2u)..(.2u,.4u);\n"
"    thdraw (-.2u,-.4u)..(-.1u,-.2u)..(-.2u,.2u)..(-.1u,.4u);\n"
"    thdraw (-.2u,.2u)--(.1u,.2u);\n"
"    thdraw (-.15u,0)--(.15u,0);\n"
"    thdraw (-.1u,-.2u)--(.2u,-.2u);\n"
"enddef;\n"
"\n"
"def p_bridge_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.3u,.2u)--(-.2u,.1u)--(.2u,.1u)--(.3u,.2u);\n"
"    thdraw (-.3u,-.2u)--(-.2u,-.1u)--(.2u,-.1u)--(.3u,-.2u);\n"
"enddef;\n"
"\n"
"def p_noequipment_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    thfill (0,-.1u)--(-.05u,.3u)--(.05u,.3u)--cycle;\n"
"    thdraw (0,-.2u) withpen PenX;\n"
"enddef;\n"
"\n"
"def p_anchor_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    thdraw fullcircle scaled .2u shifted (0.2u,0) withpen PenC;\n"
"    begingroup;\n"
"      interim linecap:=butt;\n"
"      thdraw (-.3u,0)--(.1u,0) withpen PenA;\n"
"    endgroup;\n"
"    thdraw (.1u,-.4u)--(.1u,.4u) withpen PenD;\n"
"enddef;\n"
"\n"
"def p_traverse_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.25u,.05u)..(0,-.08u)..(.25u,.05u);\n"
"    pickup pencircle scaled .18u;\n"
"    thdraw (-.25u,.05u);\n"
"    thdraw (.25u,.05u);\n"
"enddef;\n"
"\n"
"def p_rope_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .4u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thdraw unitsquare scaled .8u shifted (-0.4u,-.4u) withpen PenD;\n"
"    pickup PenC;\n"
"    thdraw (-.2u,.2u)..origin..(.1u,.1u)--(.1u,-.4u);\n"
"    pickup pencircle scaled .18u;\n"
"    thdraw (-.2u,.2u);\n"
"    thdraw (.1u,.1u);\n"
"enddef;\n"
"\n"
"def p_camp_SKBB (expr pos,r,s,al) = \n"
"    U:=(.4u, .5u);\n"
"    T:=identity aligned al shifted pos;\n"
"    pickup PenC;\n"
"    thdraw (-.4u,-.4u)--(0,.5u)--(.4u,-.4u)--cycle;\n"
"    pickup PenD;\n"
"    thdraw (0,-.4u)--(0,.5u);\n"
"enddef;\n"
"\n"
"\n"
"def p_dig_UIS (expr pos,r,s,al) = \n"
"    U:=(.4u, .5u);\n"
"    T:=identity aligned al shifted pos;\n"
"    thfill ((-.075u,-.5u){down} .. {up}(0.075u, -.5u) -- (0.075u, .15u) -- (0.3u, 0.15u) -- (0.3u, 0.5u) --\n"
"    (-.3u, .5u) -- (-.3u, .15u) -- (-.075u, .15u) -- cycle) rotated 45;\n"
"enddef;\n"
"\n"
"def p_continuation_UIS(expr pos,theta,sc,al) =\n"
"  U:=(.15u,.3u);\n"
"  T:=identity aligned al shifted pos;\n"
"  pickup PenC;\n"
"  thdraw (-.1u,.2u){up}..{down}(.1u,.2u)..{down}(0,-.05u);\n"
"  pickup PenX;\n"
"  thdraw (0,-.2u);\n"
"enddef;\n"
"\n"
"def p_station_SKBB(expr pos,mark,txt)(text flags) =\n"
"  T:=identity shifted pos;\n"
"\n"
"  if mark=4: p_station_fixed(pos)\n"
"  elseif mark=3: p_station_natural(pos)\n"
"  elseif mark=2: p_station_painted(pos)\n"
"  elseif mark=1: p_station_temporary(pos)\n"
"  fi;\n"
"  \n"
"  path path_cave;\n"
"  path_cave = (-.3u,-.25u) -- (-.2u,-.25u){dir 135} .. (0, .25u) .. {dir 225}(.2u,-.25u) -- (.3u,-.25u);\n"
"  for i=flags:\n"
"    pickup PenX;\n"
"    if i=\"entrance\":\n"
"      thdraw path_cave;\n"
"      p_label.urt(txt,pos+(0.4u,0),0,0);\n"
"    elseif i=\"sink\":\n"
"      thdraw path_cave cutbefore ((-u,0)--(u,0)) cutafter ((-u,0)--(u,0));\n"
"      pickup PenA;\n"
"      thdraw (0,-.45u) -- (0,.05u) withcolor blue;\n"
"      thdraw (-.15u,-.02u) -- (0,.05u) -- (.15u,-.02u) withcolor blue;\n"
"    elseif i=\"spring\":\n"
"      thdraw path_cave cutbefore ((-u,0)--(u,0)) cutafter ((-u,0)--(u,0));\n"
"      pickup PenA;\n"
"      thdraw (0,-.45u) -- (0,.05u) withcolor blue;\n"
"      thdraw (-.15u,-.38u) -- (0,-.45u) -- (.15u,-.38u) withcolor blue;\n"
"    elseif i=\"doline\":\n"
"      thdraw (-.5u,.05u){down}..(0,-0.6u)..{up}(.5u,.05u);\n"
"    elseif i=\"dig\":\n"
"      thdraw (-.5u,.25u) -- (-.35u,.25u)--(-.23u,-.25u)--(.23u,-.25u)--(.35u,.25u)--(.5u,.25u);\n"
"    elseif substring(0,11) of i = \"air-draught\":\n"
"      pickup PenB;\n"
"      thdraw ((0,.11u){dir-120} ..{dir-70}(0,0) .. {dir-120}(0,-.11u));\n"
"      thdraw ((0,.11u){dir-120} ..{dir-70}(0,0) .. {dir-120}(0,-.11u)) shifted (.11u,0);\n"
"      thdraw ((0,.11u){dir-120} ..{dir-70}(0,0) .. {dir-120}(0,-.11u)) shifted (-.11u,0);\n"
"    elseif i=\"continuation\":\n"
"      if picture(txt):\n"
"        picture ATTR__text;\n"
"        ATTR__text := txt;\n"
"      fi;\n"
"      begingroup;\n"
"        save T; transform T;\n"
"        p_continuation(pos+(0,.25u),0,1,(0,1));\n"
"      endgroup;\n"
"      if picture(txt):\n"
"        save ATTR__text;\n"
"      fi;\n"
"    fi;\n"
"  endfor;\n"
"%  thdraw (0,0) withpen PenX withcolor red;\n"
"enddef;\n"
"\n"
"def p_debug (expr col, pen, pos)=\n"
"    T:=identity shifted pos;\n"
"    thdraw origin withpen pencircle \n"
"      scaled if pen=0: 2pt \n"
"                 else: 4pt fi \n"
"      withcolor if col=-2: (1,.85,0)\n"
"           elseif col=-1: black \n"
"           elseif col=0: red \n"
"           else: blue fi;\n"
"enddef;\n"
"\n"
"\n"
"def p_u(expr pos,theta,sc,al) =\n"
"  T:=identity shifted pos;\n"
"  thdraw origin withpen pencircle scaled 4pt withcolor red;\n"
"enddef;\n"
"\n"
"\n"
"\n\n\n%%%%% ENDINPUT thPoint %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thLine %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for line symbols\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thLine.mp,v $\n"
"%% $Revision: 1.4 $\n"
"%%\n"
"%% Copyright (C) 2000 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"% some definitions\n"
"\n"
"vardef adjust_step (expr L, S) =     % krok is stretched a bit\n"
"  if S <= L: L / (floor(L / S))      % according to length of path\n"
"  else: L fi\n"
"enddef;\n"
"\n"
"def mark_(expr p,t,l) =\n"
"  thdraw (point t of p) --\n"
"          ((point t of p) + l * unitvector(thdir(p,t) rotated 90));\n"
"enddef;\n"
"\n"
"vardef thdir (expr p,t) =    % 1 * epsilon caused problems in scales < 1:1000\n"
"                             % n * epsilon is enough for scale 1:(n*1000)\n"
"%  ((direction t-100*epsilon of p) + (direction t+100*epsilon of p)) / 2\n"
"   postcontrol (t+1000*epsilon) of p - precontrol (t-1000*epsilon) of p\n"
"%  direction t of p\n"
"enddef;\n"
"\n"
"% walls:\n"
"\n"
"def l_wall_bedrock_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_sand_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.1u);\n"
"  pickup PenB;  \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    thdraw ((point t of P) + (uniformdeviate 1) * .4u \n"
"            * unitvector(thdir(P,t) rotated -90));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenA;  \n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_pebbles_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .35u);\n"
"  pickup PenC;\n"
"  q:=superellipse((.2u,0),(0,.1u),(-.2u,0),(0,.-.1u),.75);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q randomized (u/20) rotated (angle(thdir(P,t)) + (normaldeviate*40)) shifted point t of P;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_wall_clay_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .5u);\n"
"  pickup PenC;\n"
"  q := (-0.15u,0){up}..{down}origin..{up}(0.15u,0);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_debris_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .4u);\n"
"  pickup PenC;\n"
"%  q := ((-.1u,-.15u)--(.2,.03u)--(-.2u,.15u)--cycle) scaled 1.5;\n"
"  q := ((-.2u,-.1u)--(.2u,-.1u)--(0,.2u)--cycle) scaled 1.1;\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw q randomized (u/10) rotated uniformdeviate (360) shifted point t of P;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_wall_blocks_SKBB (expr P) = \n"
"%  pickup PenD;\n"
"%  draw P withcolor red;\n"
"\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"if dlzka > 0:\n"
"  mojkrok:=adjust_step(dlzka, 1.5u);\n"
"  pickup PenA;\n"
"  forever:\n"
"    t1 := arctime (cas + mojkrok*1/10) of P;\n"
"    t2 := arctime (cas + mojkrok*9/10) of P;\n"
"    q := ((point t1 of P) + .4u * unitvector(thdir(P,t1) rotated -90)) --\n"
"         (subpath (t1,t2) of P) --\n"
"         ((point t2 of P) + .4u * unitvector(thdir(P,t2) rotated -90));\n"
"    thdraw q randomized (u/6);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"fi;\n"
"enddef;\n"
"\n"
"def l_wall_ice_SKBB (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .5u);\n"
"  pickup PenC;\n"
"  p := (-.1u,0)--(.1u,0);\n"
"  q := (0,-.1u)--(0,.1u);\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    thdraw p shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    thdraw q shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_underlying_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_wall_unsurveyed_SKBB (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_wall_presumed_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P dashed evenly scaled (2*optical_zoom);\n"
"enddef;\n"
"\n"
"% other line symbols\n"
"\n"
"def l_pit_UIS (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.25u);\n"
"  pickup PenD;  \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    mark_ (P,t,0.2u);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"  pickup PenC;  \n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"let l_floorstep_UIS = l_pit_UIS;\n"
"\n"
"def l_overhang_SKBB (expr P) =\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.3u);\n"
"  pickup PenC;\n"
"  t1:=0;\n"
"  forever:\n"
"    t := arctime (cas + mojkrok/2) of P;\n"
"    t2 := arctime (cas + mojkrok) of P;\n"
"    thfill (subpath (t1,t2) of P) -- \n"
"      ((point t of P) + .3u * unitvector(thdir(P,t) rotated 90)) -- \n"
"      cycle;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"    t1:=t2;\n"
"  endfor;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"\n"
"def l_chimney_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_ceilingstep_SKBB (expr P) =\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.8u);\n"
"  pickup PenC;\n"
"  forever:\n"
"    t1 := arctime (cas + mojkrok*1/5) of P;\n"
"    t  := arctime (cas + mojkrok/2) of P;\n"
"    t2 := arctime (cas + mojkrok*4/5) of P;\n"
"    thdraw (subpath (t1,t2) of P);\n"
"    mark_ (P,t,0.2u);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_ceilingmeander_SKBB (expr P) =\n"
"  pair Pp;\n"
"  pair Pd;\n"
"  pair Pv;\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.8u);\n"
"  pickup PenC;\n"
"  forever:\n"
"    t  := arctime (cas + mojkrok/2) of P;\n"
"    Pp := (point t of P);\n"
"    Pd := unitvector(thdir(P,t));\n"
"    Pv := Pd rotated 90;\n"
"    thdraw (Pp + 0.1u * Pv) --\n"
"          (Pp + 0.2u * Pv);\n"
"    thdraw (Pp + 0.2u * Pv + 0.2u * Pd) --\n"
"          (Pp + 0.2u * Pv - 0.2u * Pd);\n"
"    thdraw (Pp - 0.1u * Pv) --\n"
"          (Pp - 0.2u * Pv);\n"
"    thdraw (Pp - 0.2u * Pv + 0.2u * Pd) --\n"
"          (Pp - 0.2u * Pv - 0.2u * Pd);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_floormeander_SKBB (expr P) =\n"
"  pair Pp;\n"
"  pair Pd;\n"
"  pair Pv;\n"
"  pair PPp;\n"
"  pair PPd;\n"
"  pair PPv;\n"
"\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, 0.25u);\n"
"  pickup PenC;\n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    Pp := (point t of P);\n"
"    Pd := unitvector(thdir(P,t));\n"
"    Pv := Pd rotated 90;\n"
"    thdraw (Pp + 0.1u * Pv) --\n"
"          (Pp + 0.2u * Pv);\n"
"    thdraw (Pp - 0.1u * Pv) --\n"
"          (Pp - 0.2u * Pv);\n"
"    if cas > 0:\n"
"      thdraw (PPp + 0.2u * PPv) --\n"
"          (Pp + 0.2u * Pv);\n"
"      thdraw (PPp - 0.2u * PPv) --\n"
"          (Pp - 0.2u * Pv);\n"
"    fi;\n"
"    PPp := Pp;\n"
"    PPd := Pd;\n"
"    PPv := Pv;\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"  endfor;\n"
"enddef;    \n"
"\n"
"boolean alw_perpendicular;\n"
"\n"
"def l_slope_SKBB (expr P,S)(text Q) = \n"
"%show Q;\n"
"  T:=identity;\n"
"  numeric dirs[];\n"
"  numeric lengths[];\n"
"  for i=Q:\n"
"    dirs[redpart i]:=greenpart i;\n"
"    lengths[redpart i]:=bluepart i;\n"
"  endfor;  \n"
"\n"
"\n"
"  li:=length(P); % last\n"
"\n"
"  alw_perpendicular:=true;\n"
"\n"
"  for i=0 upto li:\n"
"    if unknown dirs[i]: dirs[i]:=-1; \n"
"    else: \n"
"      if dirs[i]>-1:\n"
"        dirs[i]:=((90-dirs[i]) - angle(thdir(P,i))) mod 360; \n"
"        alw_perpendicular:=false;\n"
"      fi;\n"
"    fi;\n"
"    if unknown lengths[i]: lengths[i]:=-1; fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    d:=dirs[i];\n"
"    if d=-1:\n"
"      if (i=0) or (i=li):\n"
"        dirs[i] := angle(thdir(P,i) rotated 90) mod 360;\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i upto li:\n"
"            ni:=j;\n"
"\t    exitif dirs[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tdirs[i]:=w[dirs[pi],dirs[ni]];\n"
"%        if (dirs[i]-angle(thdir(P,i))) mod 360>180:\n"
"%          dirs[i]:=w[dirs[ni],dirs[pi]];\n"
"%\t  message(\"*******\");\n"
"%        fi;\n"
"     fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    l:=lengths[i];\n"
"    if l=-1:\n"
"      if (i=0) or (i=li):\n"
"        lengths[i] := 1cm; % should never happen!\n"
"\tthwarning(\"slope width at the end point not specified\");\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i+1 upto li:\n"
"            ni:=j;\n"
"\t    exitif lengths[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tlengths[i]:=w[lengths[pi],lengths[ni]];\n"
"\tpi:=i;\n"
"      fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"% for i=0 upto li: show lengths[i]; endfor;\n"
"\n"
"  T:=identity;\n"
"  boolean par;\n"
"  cas := 0.3u;\n"
"  krok := 0.7u;\n"
"  dlzka := (arclength P);\n"
"  if dlzka>3u: dlzka:=dlzka-0.6u fi;\n"
"  mojkrok:=adjust_step(dlzka,1.4u) / 2;\n"
"  pickup PenD;\n"
"  par := false; \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    if t mod 1>0:  % not a key point\n"
"      w := (arclength(subpath(floor t,t) of P) / \n"
"            arclength(subpath(floor t,ceiling t) of P));\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a := w[dirs[floor t],dirs[ceiling t]];\n"
"      fi;\n"
"      l := w[lengths[floor t],lengths[ceiling t]];\n"
"    else:\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a:= dirs[t];\n"
"      fi; \n"
"      l:=lengths[t];\n"
"    fi;\n"
"    \n"
"    a := a + angle(thdir(P,t));\n"
"    \n"
"    thdraw (point t of P) -- \n"
"      ((point t of P) + if par: 0.333 * fi l * unitvector(dir(a)));\n"
"    cas := cas + mojkrok;\n"
"    par := not par;\n"
"    exitif cas > dlzka + .3u + (krok / 3);  % for rounding errors\n"
"  endfor;\n"
"  if S = 1: pickup PenC; draw P fi;\n"
"%pickup pencircle scaled 3pt;\n"
"%for i=0 upto li: draw point i of P; endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_slope_BCRA (expr P,S)(text Q) = \n"
"%show Q;\n"
"  T:=identity;\n"
"  numeric dirs[];\n"
"  numeric lengths[];\n"
"  for i=Q:\n"
"    dirs[redpart i]:=greenpart i;\n"
"    lengths[redpart i]:=bluepart i;\n"
"  endfor;  \n"
"\n"
"\n"
"  li:=length(P); % last\n"
"\n"
"  alw_perpendicular:=true;\n"
"\n"
"  for i=0 upto li:\n"
"    if unknown dirs[i]: dirs[i]:=-1; \n"
"    else: \n"
"      if dirs[i]>-1:\n"
"        dirs[i]:=((90-dirs[i]) - angle(thdir(P,i))) mod 360; \n"
"        alw_perpendicular:=false;\n"
"      fi;\n"
"    fi;\n"
"    if unknown lengths[i]: lengths[i]:=-1; fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    d:=dirs[i];\n"
"    if d=-1:\n"
"      if (i=0) or (i=li):\n"
"        dirs[i] := angle(thdir(P,i) rotated 90) mod 360;\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i upto li:\n"
"            ni:=j;\n"
"\t    exitif dirs[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tdirs[i]:=w[dirs[pi],dirs[ni]];\n"
"%        if (dirs[i]-angle(thdir(P,i))) mod 360>180:\n"
"%          dirs[i]:=w[dirs[ni],dirs[pi]];\n"
"%\t  message(\"*******\");\n"
"%        fi;\n"
"     fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"%for i=0 upto li: show dirs[i]; endfor;\n"
"\n"
"  ni:=0; % next\n"
"  pi:=0; % previous\n"
"\n"
"  for i=0 upto li:\n"
"    l:=lengths[i];\n"
"    if l=-1:\n"
"      if (i=0) or (i=li):\n"
"        lengths[i] := 1cm; % should never happen!\n"
"\tthwarning(\"slope width at the end point not specified\");\n"
"\tpi:=i;\n"
"      else:\n"
"        if ni<=i:\n"
"\t  for j=i+1 upto li:\n"
"            ni:=j;\n"
"\t    exitif lengths[j]>-1;\n"
"\t  endfor;\n"
"\tfi;\n"
"\tw:=arclength(subpath(pi,i) of P) / \n"
"\t   arclength(subpath(pi,ni) of P);\n"
"\tlengths[i]:=w[lengths[pi],lengths[ni]];\n"
"\tpi:=i;\n"
"      fi;\n"
"    else:\n"
"      pi:=i;\n"
"    fi;\n"
"  endfor;\n"
"\n"
"% for i=0 upto li: show lengths[i]; endfor;\n"
"\n"
"  T:=identity;\n"
"  boolean par;\n"
"  cas := 0.3u;\n"
"  krok := 0.7u;\n"
"  dlzka := (arclength P);\n"
"  if dlzka>3u: dlzka:=dlzka-0.6u fi;\n"
"  mojkrok:=adjust_step(dlzka,1.4u) / 2;\n"
"  pickup PenD;\n"
"  par := false; \n"
"  forever:\n"
"    t := arctime cas of P;\n"
"    if t mod 1>0:  % not a key point\n"
"      w := (arclength(subpath(floor t,t) of P) / \n"
"            arclength(subpath(floor t,ceiling t) of P));\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a := w[dirs[floor t],dirs[ceiling t]];\n"
"      fi;\n"
"      l := w[lengths[floor t],lengths[ceiling t]];\n"
"    else:\n"
"      if alw_perpendicular:\n"
"        a := 90;\n"
"      else:\n"
"        a:= dirs[t];\n"
"      fi; \n"
"      l:=lengths[t];\n"
"    fi;\n"
"    \n"
"    a := a + angle(thdir(P,t));\n"
"    \n"
"    if par:\n"
"      thfill (point t of P) + mojkrok/2.5 * unitvector(dir(a+90))-- \n"
"        ((point t of P) + l * unitvector(dir(a))) --\n"
"        (point t of P) + mojkrok/2.5 * unitvector(dir(a-90)) -- cycle;\n"
"    fi;\n"
"    cas := cas + mojkrok;\n"
"    par := not par;\n"
"    exitif cas > dlzka + .3u + (krok / 3);  % for rounding errors\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_contour_UIS(expr P)(text txt) =\n"
"  T:=identity;\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"  for pnt=txt:\n"
"    if pnt=-2:\n"
"      mark_(P,arctime(arclength(P)/2) of P, 0.2u);\n"
"    elseif pnt>=0:\n"
"      mark_(P,pnt,0.2*u);\n"
"    fi;\n"
"    exitif pnt<0;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_contour_SKBB(expr P)(text txt) =\n"
"  T:=identity;\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"  for pnt=txt:\n"
"    if (pnt=-2) or (pnt=-1):\n"
"      mark_(P,arctime(arclength(P)/2) of P, 0.2u);\n"
"    elseif pnt>=0:\n"
"      mark_(P,pnt,0.2*u);\n"
"    fi;\n"
"    exitif pnt<0;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_rockborder_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  if cycle P: thclean P fi;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_rockedge_UIS (expr P) = \n"
"  T:=identity;\n"
"  pickup PenD;\n"
"  thdraw P;\n"
"enddef;\n"
"\n"
"def l_border_visible_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  draw Path;\n"
"enddef;\n"
"\n"
"def l_border_temporary_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  draw Path dashed evenly scaled optical_zoom;\n"
"enddef;\n"
"\n"
"def l_flowstone_UIS (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .7u);\n"
"  pickup PenC;  \n"
"  t1:=0;\n"
"  forever:\n"
"    t2 := arctime (cas + mojkrok) of P;\n"
"    thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 60)} ..\n"
"           {dir (angle(thdir(P,t2)) - 60)}(point t2 of P);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"    t1:=t2;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_moonmilk_UIS (expr P) = \n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength P;\n"
"  mojkrok:=adjust_step(dlzka, .3u);\n"
"  pickup PenC;  \n"
"  t1:=0;\n"
"  forever:\n"
"    t2 := arctime (cas + mojkrok) of P;\n"
"    thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 80)} ..\n"
"           {dir (angle(thdir(P,t2)) - 80)}(point t2 of P);\n"
"    cas := cas + mojkrok;\n"
"    exitif cas > dlzka + (mojkrok / 3); % for rounding errors\n"
"    t1:=t2;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_survey_surface_SKBB (expr P) =\n"
"  T:=identity;\n"
"  thdrawoptions(dashed withdots scaled (0.2 * optical_zoom) withpen PenC);\n"
"  thdraw P;\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def l_survey_cave_SKBB (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  if ATTR__scrap_centerline:\n"
"    thdraw P;\n"
"  else:\n"
"    PolygonLine:=.8u;\n"
"    pair zz[];\n"
"    for t = 0 upto length P - 1:\n"
"      zz1 := point t of P;\n"
"      zz2 := point t+1 of P;\n"
"      if length (zz2-zz1) > 2*PolygonLine:\n"
"        thdraw zz1 -- zz1 + PolygonLine * unitvector(zz2 - zz1);\n"
"        thdraw zz2 -- zz2 + PolygonLine * unitvector(zz1 - zz2);\n"
"      else:\n"
"        thdraw zz1 -- zz2;\n"
"      fi;\n"
"    endfor;\n"
"  fi;\n"
"enddef;\n"
"\n"
"def l_survey_cave_UIS (expr P) =\n"
"  T:=identity;\n"
"  pair zz[];\n"
"  pickup PenC;\n"
"  for t = 0 upto length P - 1:\n"
"    zz1 := point t of P;\n"
"    zz2 := point t+1 of P;\n"
"    draw zz1 -- zz2;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_waterflow_permanent_UIS (expr Path) =\n"
"  path ppp;\n"
"  T:=identity;\n"
"  cas := 0;\n"
"  dlzka := arclength Path;\n"
"  mojkrok:=adjust_step(dlzka, 0.5u);\n"
"    pickup PenD;  \n"
"    vardef azim = 50 + 15*normaldeviate enddef;\n"
"    az1 := azim;\n"
"    sgn := 1;\n"
"    ppp := point 0 of Path;\n"
"    forever:\n"
"        t1 := arctime cas of Path;\n"
"        t2 := arctime (cas+mojkrok) of Path;\n"
"        if cas+1.1*mojkrok > dlzka:\n"
"            az2 := 0;\n"
"        else:\n"
"            az2 := azim;\n"
"        fi;\n"
"        d1 := angle(thdir(Path,t1)) + sgn * az1;\n"
"        d2 := angle(thdir(Path,t2)) - sgn * az2;\n"
"        ppp := ppp & (point t1 of Path){dir d1} .. {dir d2}(point t2 of Path);\n"
"        az1 := az2;\n"
"        sgn := -1 * sgn;\n"
"        cas := cas + mojkrok;\n"
"        exitif cas > dlzka + mojkrok/3;     % for rounding errors\n"
"    endfor;\n"
"%    drawarrow ppp;\n"
"    thdraw ppp;\n"
"    thdrawoptions();\n"
"    oldahlength:=ahlength;\n"
"    ahlength:=ahlength*optical_zoom;\n"
"    thdraw arrowhead ppp;\n"
"    thfill arrowhead ppp;\n"
"    ahlength:=oldahlength;\n"
"enddef;\n"
"\n"
"def l_waterflow_intermittent_SKBB (expr Path) =\n"
"  thdrawoptions(dashed evenly scaled optical_zoom);\n"
"  l_waterflow_permanent_UIS (Path);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def l_waterflow_conjectural_SKBB (expr Path) =\n"
"  thdrawoptions(dashed withdots scaled (0.5 * optical_zoom) withpen PenB);\n"
"  l_waterflow_permanent_UIS (Path);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"def l_invisible (expr P) = \n"
"enddef;\n"
"\n"
"def l_undefined (expr P) = \n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P withcolor red;\n"
"  thwarning(\"undefined line symbol used\");\n"
"enddef;\n"
"\n"
"% Q = 0 -- no arrows\n"
"%     1 -- end\n"
"%     2 -- begin\n"
"%     3 -- both\n"
"\n"
"def l_arrow_SKBB (expr P, Q) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P;\n"
"  p := (-.1u,-.25u)--(0,0)--(.1u,-.25u);\n"
"  if odd Q:\n"
"    draw p rotated (angle(thdir(P,0))+90) shifted (point 0 of P);\n"
"  fi;\n"
"  if Q>1:\n"
"    draw p rotated (angle(thdir(P,length P))-90) \n"
"         shifted (point infinity of P);\n"
"  fi;\n"
"enddef;\n"
"\n"
"def l_mapconnection_SKBB (expr P) =\n"
"  thdrawoptions(dashed withdots scaled (0.5 * optical_zoom) withpen PenB);\n"
"  l_arrow_SKBB(P,3);\n"
"  thdrawoptions();\n"
"enddef;\n"
"\n"
"\n"
"def l_section_SKBB (expr P)(text txt) =\n"
"  T:=identity;\n"
"  path Q; Q = punked P;\n"
"  pickup PenC;\n"
"  for t = 0 upto length P - 1:\n"
"    pair zz[];\n"
"    zz1 := point t of P;\n"
"    zz2 := point t+1 of P;\n"
"    zz3 := postcontrol t of P;\n"
"    zz4 := precontrol t+1 of P;\n"
"    if (length(zz3-1/3[zz1,zz2]) > 0.1pt) or\n"
"       (length(zz4-2/3[zz1,zz2]) > 0.1pt):\n"
"      zz5 = whatever[zz1,zz2];\n"
"      (zz3-zz5) = whatever * (zz1-zz2) rotated 90;\n"
"      draw zz1--zz5;\n"
"      zz6 = whatever[zz1,zz2];\n"
"      (zz4-zz6) = whatever * (zz1-zz2) rotated 90;\n"
"      draw zz2--zz6;\n"
"    else:\n"
"      draw zz1--zz2;\n"
"    fi;\n"
"  endfor;\n"
"  for pnt=txt:\n"
"    if pnt=-1:\n"
"    else:\n"
"      T:=identity rotated angle(thdir(Q,pnt)) shifted (point pnt of Q);\n"
"      pickup PenC;\n"
"      thdraw (0,0)--(0,.8u);\n"
"      thdraw (-.1u,.55u)--(0,.8u)--(.1u,.55u);\n"
"    fi;\n"
"    exitif pnt=-1;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"let l_border_invisible = l_invisible;\n"
"let l_wall_invisible = l_invisible;\n"
"\n"
"def l_debug (expr col, pen, P) =\n"
"  T:=identity;\n"
"  pickup if pen=0: PenD else: PenB fi;\n"
"  thdraw P \n"
"    withcolor if col=-2: (1,.85,0)\n"
"          elseif col=-1: black \n"
"           elseif col=0: red \n"
"                   else: blue fi;\n"
"enddef;\n"
"\n"
"\n"
"def l_u (expr P) =\n"
"  T:=identity;\n"
"  pickup PenA;\n"
"  thdraw P withcolor red;\n"
"enddef;\n"
"\n"
"\n"
"def l_gradient_UIS (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  thdraw P;\n"
"  p:=(-.15u,-.4u)--(0,0)--(.15u,-.4u)--cycle;\n"
"  thfill (p rotated (angle(thdir(P,length P))-90) \n"
"         shifted (point infinity of P));\n"
"  thdraw (p rotated (angle(thdir(P,length P))-90) \n"
"         shifted (point infinity of P));\n"
"enddef;\n"
"\n"
"def l_gradient_BCRA (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  for t = 0 upto length P - 1:\n"
"    pair zz[];\n"
"    zz1 := point t of P;\n"
"    zz2 := point t+1 of P;\n"
"    zz3 := unitvector(zz2 - zz1);\n"
"    thfill zz1 + u/3 * zz3 + .25u * (zz3 rotated 90) --\n"
"           zz2 - u/3 * zz3 --\n"
"\t   zz1 + u/3 * zz3 + .25u * (zz3 rotated -90) -- cycle;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"\n"
"def l_rope_SKBB (expr P,exact) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  if exact:\n"
"    draw P;\n"
"  else:\n"
"    d:=0.5u;\n"
"    for i:=0 upto (length P - 2):\n"
"      x1 := xpart point i of P;\n"
"      y1 := ypart point i of P;\n"
"      x2 := xpart point i+1 of P;\n"
"      y2 := ypart point i+1 of P;\n"
"    \n"
"      dx1:=x1; dy1:=y1; x1:=0; y1:=0; x2:=x2-dx1; y2:=y2-dy1;\n"
"      if y2 > y1:\n"
"        y3 := y1 - d;\n"
"        x3 := x1 + (x2-x1)*sqrt(d)/(sqrt(d)+sqrt(y2-y1+d));\n"
"      else:\n"
"        y3 := y2 - d;\n"
"        x3 := x1 + (x2-x1)*sqrt(y1-y2+d)/(sqrt(d)+sqrt(y1-y2+d));\n"
"      fi;\n"
"      numeric a,b,c;\n"
"      a*x1/10*x1 + b/10*x1 + c/10 = y1/10;\n"
"      a*x2/10*x2 + b/10*x2 + c/10 = y2/10;\n"
"      a*x3/10*x3 + b/10*x3 + c/10 = y3/10;\n"
"      draw (x1+dx1,y1+dy1)\n"
"      for t = x1 step (x2-x1)/20 until x2+10*epsilon:\n"
"        -- (t+dx1,a*t*t+b*t+c+dy1)\n"
"      endfor;\n"
"    endfor;\n"
"    pair x;\n"
"    x = point (length P)-1 of P + whatewer * down;\n"
"    x = point (length P) of P + whatever * right;\n"
"    draw point (length P)-1 of P -- x;\n"
"%    thdraw point length P of P withpen pencircle scaled 0.3u withcolor red;\n"
"  fi;\n"
"  for i:=0 upto length P if not exact: -1 fi:\n"
"    thdraw point i of P withpen pencircle scaled 0.3u;\n"
"  endfor;\n"
"enddef;\n"
"\n"
"def l_border_presumed_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  draw Path dashed evenly scaled (0.25 * optical_zoom);\n"
"enddef;\n"
"\n\n\n%%%%% ENDINPUT thLine %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thArea %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines tiling patterns\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thPatterns.mp,v $\n"
"%% $Revision: 1.6 $\n"
"%%\n"
"%% Copyright (C) 2000-2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"if unknown a_water_UIS: else: endinput fi;\n"
"\n"
"% patterns\n"
"\n"
"beginpattern(pattern_water_UIS);\n"
"    draw origin--10up withpen pensquare scaled (0.02u);\n"
"    patternxstep(.18u);\n"
"    patterntransform(identity rotated 45);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_sump_UIS);\n"
"    draw origin--(0,.25u) withpen pensquare scaled (0.02u);\n"
"    draw origin--(.25u,0) withpen pensquare scaled (0.02u);\n"
"    patterntransform(identity rotated 45);\n"
"endpattern;\n"
"\n"
"beginpattern(pattern_sand_UIS);\n"
"    pickup PenC;\n"
"    draw (0.2u,.3u);\n"
"    draw (0.35u,.7u);\n"
"    draw (0.6u,.5u);\n"
"    draw (0.8u,.1u);    \n"
"endpattern;\n"
"\n"
"beginpattern(pattern_debris_SKBB);\n"
"    pickup PenC;\n"
"    p:=(-.15u,0)--(.15u,0);\n"
"    draw p rotated -40 shifted (.2u,.3u);\n"
"    draw p rotated 70 shifted (.9u,1.5u);\n"
"    draw p rotated 20 shifted (1.5u,.8u);\n"
"%    draw p rotated 95 shifted (.9u,.8u);\n"
"endpattern;\n"
"\n"
"\n"
"beginpattern(pattern_moonmilk_SKBB);\n"
"    pickup PenC;\n"
"    p:=(-.5u,0){down} .. {up}(-.1666u,0){down}..\n"
"        {up}(.1666u,0){down} .. {up}(.5u,0);\n"
"    draw p;\n"
"    draw p shifted (0.5u,0.3u);\n"
"    patternxstep(1.0u);\n"
"    patternystep(0.6u);\n"
"endpattern;\n"
"\n"
"\n"
"beginpattern(pattern_flowstone_ASF);\n"
"    pickup PenC;\n"
"    p:=(-.35u,0){dir -60} .. {dir 60}(0.35u,0);\n"
"    draw p;\n"
"    draw p shifted (0.35u,0.4u);\n"
"    patternxstep(u);\n"
"    patternystep(0.8u);\n"
"endpattern;\n"
"\n"
"\n"
"beginpattern(pattern_empty);\n"
"  patternbbox(0,0,10,10);\n"
"  patternstep(10,10);\n"
"endpattern;\n"
"\n"
"% symbols\n"
"\n"
"def a_water_UIS (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_water_UIS;\n"
"enddef;\n"
"\n"
"def a_sump_UIS (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_sump_UIS;\n"
"enddef;\n"
"\n"
"\n"
"def a_flowstone_ASF (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_flowstone_ASF;\n"
"enddef;\n"
"\n"
"\n"
"def a_moonmilk_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"  thfill Path withpattern pattern_moonmilk_SKBB;\n"
"enddef;\n"
"\n"
"\n"
"\n"
"def a_sand_UIS (expr p) =\n"
"  T:=identity;\n"
"%  thclean p;\n"
"  pickup PenC;\n"
"  path q; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1u until ypart urcorner q:\n"
"        draw origin shifted ((i,j) randomized 0.7u) withpen PenC;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_debris_UIS (expr Path) =\n"
"  T:=identity;\n"
"%  thclean Path;\n"
"  thfill Path withpattern pattern_debris_SKBB;\n"
"enddef;\n"
"\n"
"\n"
"def a_bedrock_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"enddef;\n"
"\n"
"\n"
"def a_dimensions_SKBB (expr Path) =\n"
"  T:=identity;\n"
"  thclean Path;\n"
"enddef;\n"
"\n"
"\n"
"def a_debris_SKBB (expr p) =\n"
"  T:=identity;\n"
"%  thclean p;\n"
"  pickup PenC;\n"
"  path q; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1u until ypart urcorner q:\n"
"        draw ((-.2u,0)--(.2u,0)) \n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 0.6u) withpen PenC;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_clay_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        qq := ((-.25u,0){up}..origin{down}..{up}(0.25u,0)) randomized (u/15)\n"
"             shifted ((i,j) randomized 1.3u);\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_ice_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q; q = bbox p;\n"
"  picture tmp_pic, tmp_ice; \n"
"  pair z;\n"
"  tmp_ice := image (\n"
"    draw (-.2u,0)--(.2u,0);\n"
"    draw (0,-.2u)--(0,.2u);\n"
"  );\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        z := ((i,j) randomized 1.3u);\n"
"\tif xpart (p intersectiontimes ((bbox tmp_ice) shifted z)) < 0:\n"
"\t  draw tmp_ice shifted z;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"\n"
"def a_snow_SKBB (expr P) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q; q = bbox P;\n"
"  picture tmp_pic, tmp_sn; \n"
"  pair z;\n"
"  tmp_sn := image(\n"
"    pickup PenC;\n"
"    p := origin--(0,.2*u);\n"
"    draw p; draw p rotated (60); draw p rotated (120);\n"
"    draw p rotated (180); draw p rotated (240); draw p rotated (300);\n"
"    p := ((0,.3u)--(0,0.2u)--(0.1u,0.2u)) rotatedaround ((0,0.2u),45);\n"
"    draw p; draw p rotated (60); draw p rotated (120);\n"
"    draw p rotated (180); draw p rotated (240);\n"
"    draw p rotated (300);\n"
"  );\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        z:=((i,j) randomized 1.3u);\n"
"\tif xpart (P intersectiontimes ((bbox tmp_sn) shifted z)) < 0:\n"
"          draw tmp_sn shifted z;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to P;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_blocks_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  picture tmp_pic; \n"
"  uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart llcorner q)/100);\n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 2uu until xpart urcorner q:\n"
"      for j = ypart llcorner q step 2uu until ypart urcorner q:\n"
"        qq := punked (((-.5uu,-.5uu)--(.5uu,-.5uu)--(.5uu,.5uu)--(-.5uu,.5uu)--cycle) \n"
"\t     randomized (uu/2))\n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 1.6uu);\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thclean qq;\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_blocks_SKBB_ (expr p,o,s_beg,s_end,d_beg,d_end) =\n"
"  T:=identity;\n"
"  orient = 90-o;\n"
"  pickup PenC;\n"
"  path q[], qq; q1 = bbox p;\n"
"  draw q1; draw p;\n"
"  q2 = llcorner q1 .. lrcorner q1 .. urcorner q1 .. ulcorner q1 .. cycle;\n"
"  draw q2;\n"
"  pair zz[];\n"
"  radius := .5*length(llcorner q1 - urcorner q1);\n"
"  zz1 := .5[llcorner q1,urcorner q1];\n"
"  zz2 := zz1 - dir(orient)*radius;\n"
"  zz3 = zz1 rotatedaround (zz2,90);\n"
"  draw zz1 withpen pencircle scaled 2mm;\n"
"  draw zz2 withpen pencircle scaled 2mm;\n"
"  draw zz3 withpen pencircle scaled 2mm;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    j := 0;\n"
"    forever:\n"
"      i := 0;\n"
"      forever:\n"
"        qq := punked (((-.5,-.5)--(.5,-.5)--(.5,.5)--(-.5,.5)--cycle) \n"
"             scaled (0.7(5u-(j/(2*radius))[u*s_beg,u*s_end]))\n"
"\t     randomized (u/2))\n"
"             rotated uniformdeviate(360) \n"
"             shifted (((zz3 + (i,j)) rotatedaround (zz3,-o)) randomized 1.6u);\n"
"        draw ((zz3 + (i,j)) rotatedaround (zz3,-o)) withpen pencircle scaled 1mm withcolor red;\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thclean qq;\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"        i := i + (j/(2*radius))[u*d_beg,u*d_end];\n"
"        exitif i > 2*radius;\n"
"      endfor;  \n"
"      j := j + (j/(2*radius))[u*d_beg,u*d_end];\n"
"      exitif j > 2*radius;\n"
"    endfor;\n"
"  );\n"
"%  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"\n"
"def a_pebbles_SKBB (expr p) =\n"
"  T:=identity;\n"
"  pickup PenC;\n"
"  path q, qq; q = bbox p;\n"
"  picture tmp_pic; \n"
"  tmp_pic := image(\n"
"    for i = xpart llcorner q step 1.5u until xpart urcorner q:\n"
"      for j = ypart llcorner q step 1.5u until ypart urcorner q:\n"
"        qq := (superellipse((.2u,0),(0,.1u),(-.2u,0),(0,.-.1u),.75))\n"
"%             randomized (u/25)\n"
"             rotated uniformdeviate(360) \n"
"             shifted ((i,j) randomized 0.8u);\n"
"\tif xpart (p intersectiontimes qq) < 0:\n"
"\t  thdraw qq;\n"
"\tfi;\n"
"      endfor;  \n"
"    endfor;\n"
"  );\n"
"  clip tmp_pic to p;\n"
"  draw tmp_pic;\n"
"enddef;\n"
"\n"
"def a_u (expr p) =\n"
"    T:=identity;\n"
"    thfill p withcolor red;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thArea %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thText %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for labels\n"
"%%\n"
"%% $Date: 2003/07/01 09:06:44 $\n"
"%% $RCSfile: thText.mp,v $\n"
"%% $Revision: 1.6 $\n"
"%%\n"
"%% Copyright (C) 2000-2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"labeloffset:=0bp;\n"
"\n"
"def l_label(expr txt,path) =\n"
"  picture pict,pic;\n"
"  pair pos;\n"
"  numeric dx[],dy[],ptime;\n"
"  string ss,ch;\n"
"\n"
"  pic := thelabel(txt,(0,0));\n"
"  strl := xpart(lrcorner pic - llcorner pic);\n"
"  pathl := arclength (path);\n"
"  dx0 := xpart(llcorner pic);\n"
"%  dy0 := ypart(llcorner pic);\n"
"\n"
"  if strl>pathl:\n"
"    txtzoom := pathl / strl;\n"
"    thwarning(\"text scaled down to fit the path\");\n"
"  else:\n"
"    txtzoom := 1;\n"
"  fi;\n"
"  zoom := pathl / strl;\n"
"\n"
"  for p within pic:\n"
"    if textual p:                                \n"
"      ss := textpart p;\n"
"      dx1 := xpart p;\n"
"      dy1 := ypart p;\n"
"      dx2 := dx1;\n"
"\n"
"      if xxpart p / yypart p <> 1: message(\"Error: distorted text!\") fi;\n"
"      txtscale := txtzoom * xxpart p;\n"
"\n"
"      l := length(ss);\n"
"      ptime := 0;\n"
"      for i=0 upto (l - 1):\n"
"        ch := substring(i,i+1) of ss;\n"
"        pict := ch infont fontpart p scaled txtscale;\n"
"        charwidth := xpart (lrcorner pict - llcorner pict) / txtzoom;\n"
"        dy2 := ypart lrcorner pict / txtzoom;\n"
"        ptime := (dx2 - dx0 + 0.5*charwidth) * zoom;\n"
"        t := arctime ptime of (path);\n"
"        pos := point t of path + \n"
"          (dy1+dy2)*txtzoom*unitvector((direction t of path) rotated 90);\n"
"        begingroup\n"
"%          interim labeloffset:=0bp;\n"
"          lab:=thelabel.top(pict,pos);\n"
"          process_label(pos,angle direction t of path);\n"
"        endgroup;\n"
"        dx2 := dx2 + charwidth;\n"
"      endfor;\n"
"\n"
"    else message(\"This can't happen!\")\n"
"    fi;\n"
"  endfor;\n"
"  % draw path;\n"
"enddef;\n"
"\n"
"vardef p_label@#(expr txt,pos,rot,mode) =\n"
"  if (mode=1) or (mode=7): interim labeloffset:=(u/8) fi;\n"
"  lab:=thelabel@#(txt, pos);\n"
"  if mode>1: pickup PenD fi;\n"
"  if mode=1:\n"
"    pickup pencircle scaled (u/6);\n"
"    drawdot(pos);\n"
"    process_label(pos,0);\n"
"  elseif mode=2: process_uplabel;       \n"
"  elseif mode=3: process_downlabel;\n"
"  elseif mode=4: process_updownlabel;\n"
"  elseif mode=5: process_circledlabel;\n"
"  elseif mode=6: process_boxedlabel;\n"
"  elseif mode=7: process_label(pos,rot);  % station name\n"
"  elseif mode=8: process_filledlabel(pos, rot);\n"
"  else: process_label(pos,rot); fi;\n"
"enddef;\n"
"\n"
"def p_wallaltitude (expr pprev,pos,pnext,txt) =\n"
"  rot:=angle(unitvector(pnext-pos)+unitvector(pos-pprev)) - 90;\n"
"  pickup PenD;\n"
"  pair zz;\n"
"%  zz:=(pos + 3*unitvector(dir rot));\n"
"  zz:=(pos + (u/4)*unitvector(dir rot));\n"
"  draw (pos)--zz;\n"
"  begingroup \n"
"%    interim labeloffset:=2pt;\n"
"    interim labeloffset:=(u/12);\n"
"    if horiz_labels:\n"
"      rot:=rot mod 360;\n"
"      if rot<=22.5: lab:=thelabel.rt(txt, zz);\n"
"      elseif rot<=67.5: lab:=thelabel.urt(txt, zz);\n"
"      elseif rot<=112.5: lab:=thelabel.top(txt, zz);\n"
"      elseif rot<=157.5: lab:=thelabel.ulft(txt, zz);\n"
"      elseif rot<=202.5: lab:=thelabel.lft(txt, zz);\n"
"      elseif rot<=247.5: lab:=thelabel.llft(txt, zz);\n"
"      elseif rot<=292.5: lab:=thelabel.bot(txt, zz);\n"
"      elseif rot<=337.5: lab:=thelabel.lrt(txt, zz);\n"
"      else: lab:=thelabel.rt(txt, zz);\n"
"      fi;\n"
"    else:\n"
"      if (abs rot>90) and (abs rot <=270):\n"
"        rot:=rot-180;\n"
"        lab:=thelabel.lft(txt, pos);\n"
"      else:\n"
"        lab:=thelabel.rt(txt, pos);\n"
"      fi;\n"
"    fi;\n"
"    process_label(pos, if horiz_labels: 0 else: rot fi);\n"
"  endgroup;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thText %%%%%\n\n\n"
"\n\n\n%%%%% INPUT thSpecial %%%%%\n\n\n"
"%% therion source code\n"
"%%\n"
"%% This file defines macros for special symbols\n"
"%%\n"
"%% $Date: $\n"
"%% $RCSfile: $\n"
"%% $Revision: $\n"
"%%\n"
"%% Copyright (C) 2004 Martin Budaj\n"
"%%\n"
"%% -------------------------------------------------------------------- \n"
"%% This program is free software; you can redistribute it and/or modify\n"
"%% it under the terms of the GNU General Public License as published by\n"
"%% the Free Software Foundation; either version 2 of the License, or\n"
"%% any later version.\n"
"%%\n"
"%% This program is distributed in the hope that it will be useful,\n"
"%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"%% GNU General Public License for more details.\n"
"%% \n"
"%% You should have received a copy of the GNU General Public License\n"
"%% along with this program; if not, write to the Free Software\n"
"%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
"%% --------------------------------------------------------------------\n"
"\n"
"def s_northarrow_SKBB_old (expr rot) = \n"
"  T:=identity;\n"
"  picture tmp_pic;\n"
"  tmp_pic = image (\n"
"    begingroup\n"
"      interim defaultscale:=3;\n"
"      label(if (lang=\"sk\") or (lang=\"cz\"): \"S\" else: \"N\" fi, origin);\n"
"    endgroup;\n"
"    drawarrow (0,-1cm)--(0,1cm);\n"
"  );\n"
"  draw tmp_pic rotatedaround(origin, -rot);\n"
"enddef;\n"
"\n"
"def s_northarrow_SKBB (expr rot) =\n"
"  T:=identity scaled 0.7 rotated -rot;\n"
"  thdraw (-.5cm,-1cm)--(0,1.5cm)--(.5cm,-1cm)--(0,-.5cm)--cycle;\n"
"  thfill (-.5cm,-1cm)--(0,1.5cm)--(0,-.5cm)--cycle;\n"
"enddef;\n"
"\n"
"def s_scalebar_SKBB (expr l, units, txt) = \n"
"  begingroup\n"
"    interim warningcheck:=0;\n"
"    tmpl:=l / Scale * cm * units / 2;\n"
"  endgroup;\n"
"  pickup PenC;\n"
"  draw (-tmpl,0)--(tmpl,0);\n"
"  draw (-tmpl,0)--(-tmpl,2bp);\n"
"  draw (tmpl,0)--(tmpl,2bp);\n"
"  begingroup\n"
"    interim labeloffset:=2bp;\n"
"    label.top(thTEX(decimal (l) & \"\\thinspace\" & txt),origin);\n"
"  endgroup\n"
"enddef;\n"
"\n"
"def s_scalebar_SM (expr l, units, txt) = \n"
"  begingroup\n"
"    interim warningcheck:=0;\n"
"    tmpl:=l / Scale * cm * units / 2;\n"
"  endgroup;\n"
"  pickup PenC;\n"
"  draw (-tmpl,0)--(tmpl,0);\n"
"  draw (-tmpl,0)--(-tmpl,2bp);\n"
"  draw (tmpl,0)--(tmpl,2bp);\n"
"  draw (0,0)--(0,2bp);\n"
"  begingroup\n"
"    interim labeloffset:=3.5bp;\n"
"    label.top(thTEX(decimal (0)),(-tmpl,0));\n"
"    label.top(thTEX(decimal (l/2)),origin);\n"
"    label.top(thTEX(decimal (l) & \"\\thinspace\" & txt),(tmpl,0));\n"
"  endgroup\n"
"enddef;\n"
"\n"
"\n"
"def s_hgrid_SM (expr xpos, ypos, xsize, ysize) =\n"
"  pickup PenD;\n"
"  draw (\n"
"    if xpos < 0: 0 else: -5mm fi, 0\n"
"  ) -- (\n"
"    if xpos > 0: 0 else: 5mm fi, 0\n"
"  );\n"
"  draw (\n"
"    0, if ypos < 0: 0 else: -5mm fi\n"
"  ) -- (\n"
"    0, if ypos > 0: 0 else: 5mm fi\n"
"  );\n"
"enddef;\n"
"\n"
"\n"
"def s_vgrid_SM (expr xpos, ypos, xsize, ysize) =\n"
"  pickup PenD;\n"
"  draw (\n"
"    if xpos < 0: 0 else: -xsize/2 fi, 0\n"
"  ) -- (\n"
"    if xpos > 0: 0 else: xsize/2 fi, 0\n"
"  ) dashed evenly;\n"
"enddef;\n"
"\n"
"\n\n\n%%%%% ENDINPUT thSpecial %%%%%\n\n\n"
"\n"
"\n\n\n%%%%% INPUT thTrans %%%%%\n\n\n"
"% default translations\n"
"\n"
"let p_station_fixed = p_station_fixed_ASF;\n"
"let p_station_painted = p_station_painted_SKBB;\n"
"let p_station_natural = p_station_natural_ASF;              \n"
"let p_station_temporary = p_station_temporary_ASF;\n"
"\n"
"let p_waterflow_paleo = p_waterflow_paleo_UIS;\n"
"let p_waterflow_permanent = p_waterflow_permanent_UIS;\n"
"let p_waterflow_intermittent = p_waterflow_intermittent_UIS;\n"
"\n"
"let p_stalactite = p_stalactite_UIS;\n"
"let p_stalagmite = p_stalagmite_UIS;\n"
"let p_pillar = p_pillar_UIS;\n"
"let p_curtain = p_curtain_UIS;\n"
"let p_helictite = p_helictite_UIS;\n"
"let p_sodastraw = p_sodastraw_UIS;\n"
"let p_crystal = p_crystal_UIS;\n"
"let p_flowstone = p_flowstone_UIS;\n"
"let p_moonmilk = p_moonmilk_UIS;\n"
"let p_wallcalcite = p_wallcalcite_UIS;\n"
"let p_popcorn = p_popcorn_UIS;\n"
"let p_disk = p_disk_UIS;\n"
"let p_gypsum = p_gypsum_NSS;\n"
"let p_aragonite = p_aragonite_NSS;\n"
"let p_cavepearl = p_cavepearl_SKBB;\n"
"let p_gypsumflower = p_gypsumflower_NSS;\n"
"let p_rimstonepool = p_rimstonepool_ASF;\n"
"let p_rimstonedam = p_rimstonedam_ASF;\n"
"let p_anastomosis = p_anastomosis_UIS;\n"
"let p_karren = p_karren_UIS;\n"
"let p_scallop = p_scallop_UIS;\n"
"let p_flute = p_flute_UIS;\n"
"let p_raft = p_raft_NSS;\n"
"let p_raftcone = p_raftcone_NSS;\n"
"let p_spring = p_spring_SKBB;\n"
"let p_sink = p_sink_SKBB;\n"
"let p_narrowend = p_narrowend_UIS;\n"
"let p_lowend = p_lowend_UIS;\n"
"let p_flowstonechoke = p_flowstonechoke_NSS;\n"
"let p_breakdownchoke = p_breakdownchoke_NSS;\n"
"let p_bedrock = p_bedrock_ASF;\n"
"let p_clay = p_clay_SKBB;                        \n"
"let p_sand = p_sand_UIS;\n"
"let p_pebbles = p_pebbles_UIS;\n"
"let p_debris = p_debris_UIS;\n"
"let p_blocks = p_blocks_UIS;\n"
"let p_water = p_water_UIS;\n"
"let p_ice = p_ice_UIS;\n"
"let p_snow = p_snow_SKBB;\n"
"let p_archeomaterial = p_archeomaterial_UIS;\n"
"let p_paleomaterial = p_paleomaterial_UIS;\n"
"let p_guano = p_guano_UIS;\n"
"let p_vegetabledebris = p_vegetabledebris_ASF;\n"
"let p_root = p_root_ASF;\n"
"let p_entrance = p_entrance_UIS;\n"
"let p_gradient = p_gradient_UIS;\n"
"let p_rope = p_rope_SKBB;          \n"
"let p_fixedladder = p_fixedladder_SKBB;   \n"
"let p_ropeladder = p_ropeladder_SKBB;    \n"
"let p_steps = p_steps_SKBB;         \n"
"let p_bridge = p_bridge_SKBB;        \n"
"let p_traverse = p_traverse_SKBB;\n"
"let p_anchor = p_anchor_SKBB;\n"
"let p_camp = p_camp_SKBB;\n"
"let p_dig = p_dig_UIS;\n"
"let p_noequipment = p_noequipment_SKBB;\n"
"let p_sectionarrow = p_sectionarrow_SKBB;\n"
"let p_continuation = p_continuation_UIS;\n"
"let p_airdraught = p_airdraught_UIS;\n"
"let p_airdraught_winter = p_airdraught_winter_UIS;\n"
"let p_airdraught_summer = p_airdraught_summer_UIS;\n"
"let p_station = p_station_SKBB;\n"
"\n"
"let l_wall_bedrock = l_wall_bedrock_UIS;\n"
"let l_wall_sand = l_wall_sand_SKBB;\n"
"let l_wall_clay = l_wall_clay_SKBB;\n"
"let l_wall_pebbles = l_wall_pebbles_SKBB;\n"
"let l_wall_debris = l_wall_debris_SKBB;\n"
"let l_wall_blocks = l_wall_blocks_SKBB;\n"
"let l_wall_ice = l_wall_ice_SKBB;\n"
"let l_wall_underlying = l_wall_underlying_UIS;\n"
"let l_wall_unsurveyed = l_wall_unsurveyed_SKBB;\n"
"let l_wall_presumed = l_wall_presumed_UIS;\n"
"%let l_wall_invisible = l_wall_invisible;\n"
"\n"
"let l_waterflow_permanent = l_waterflow_permanent_UIS;\n"
"let l_waterflow_intermittent = l_waterflow_intermittent_SKBB;\n"
"let l_waterflow_conjectural = l_waterflow_conjectural_SKBB;\n"
"\n"
"let l_border_visible = l_border_visible_SKBB;\n"
"let l_border_temporary = l_border_temporary_SKBB;\n"
"let l_border_presumed = l_border_presumed_SKBB;\n"
"%let l_border_invisible = l_border_invisible;\n"
"\n"
"let l_floorstep = l_floorstep_UIS;\n"
"let l_pit = l_pit_UIS;\n"
"let l_ceilingstep = l_ceilingstep_SKBB;\n"
"let l_chimney = l_chimney_UIS;\n"
"let l_overhang = l_overhang_SKBB;\n"
"let l_slope = l_slope_SKBB;\n"
"let l_ceilingmeander = l_ceilingmeander_SKBB;\n"
"let l_floormeander = l_floormeander_SKBB;\n"
"let l_contour = l_contour_SKBB;\n"
"let l_rockborder = l_rockborder_UIS;\n"
"let l_rockedge = l_rockedge_UIS;\n"
"let l_flowstone = l_flowstone_UIS;\n"
"let l_moonmilk = l_moonmilk_UIS;\n"
"let l_section = l_section_SKBB;\n"
"let l_survey_cave = l_survey_cave_SKBB;\n"
"let l_survey_surface = l_survey_surface_SKBB;\n"
"let l_arrow = l_arrow_SKBB;\n"
"let l_gradient = l_gradient_UIS;\n"
"let l_mapconnection = l_mapconnection_SKBB;\n"
"\n"
"let a_water = a_water_UIS;\n"
"let a_sump = a_sump_UIS;\n"
"let a_sand = a_sand_UIS;\n"
"let a_debris = a_debris_SKBB;\n"
"let a_blocks = a_blocks_SKBB;\n"
"let a_snow = a_snow_SKBB;\n"
"let a_ice = a_ice_SKBB;\n"
"let a_pebbles = a_pebbles_SKBB;\n"
"let a_clay = a_clay_SKBB;\n"
"let a_bedrock = a_bedrock_SKBB;\n"
"let a_flowstone = a_flowstone_ASF;\n"
"let a_moonmilk = a_moonmilk_SKBB;\n"
"let a_dimensions = a_dimensions_SKBB;\n"
"\n"
"let s_northarrow = s_northarrow_SKBB;\n"
"let s_scalebar = s_scalebar_SKBB;\n"
"let s_hgrid = s_hgrid_SM;\n"
"let s_vgrid = s_vgrid_SM;\n"
"\n\n\n%%%%% ENDINPUT thTrans %%%%%\n\n\n"
"\n"
"nonstopmode;\n"
"initsymbol(\"s_hgrid_SM\");\n"
"initsymbol(\"s_northarrow_SKBB\");\n"
"initsymbol(\"s_scalebar_SKBB\");\n"
"initsymbol(\"s_scalebar_SM\");\n"
"initsymbol(\"s_vgrid_SM\");\n"
"initsymbol(\"p_airdraught_UIS\");\n"
"initsymbol(\"p_airdraught_summer_UIS\");\n"
"initsymbol(\"p_airdraught_winter_UIS\");\n"
"initsymbol(\"p_anastomosis_UIS\");\n"
"initsymbol(\"p_anchor_SKBB\");\n"
"initsymbol(\"p_aragonite_NSS\");\n"
"initsymbol(\"p_archeomaterial_UIS\");\n"
"initsymbol(\"p_bedrock_ASF\");\n"
"initsymbol(\"p_blocks_UIS\");\n"
"initsymbol(\"p_breakdownchoke_NSS\");\n"
"initsymbol(\"p_bridge_SKBB\");\n"
"initsymbol(\"p_camp_SKBB\");\n"
"initsymbol(\"p_cavepearl_SKBB\");\n"
"initsymbol(\"p_clay_SKBB\");\n"
"initsymbol(\"p_continuation_UIS\");\n"
"initsymbol(\"p_crystal_UIS\");\n"
"initsymbol(\"p_curtain_UIS\");\n"
"initsymbol(\"p_debris_UIS\");\n"
"initsymbol(\"p_dig_UIS\");\n"
"initsymbol(\"p_disk_UIS\");\n"
"initsymbol(\"p_entrance_UIS\");\n"
"initsymbol(\"p_fixedladder_SKBB\");\n"
"initsymbol(\"p_flowstone_UIS\");\n"
"initsymbol(\"p_flowstonechoke_NSS\");\n"
"initsymbol(\"p_flute_UIS\");\n"
"initsymbol(\"p_gradient_BCRA\");\n"
"initsymbol(\"p_gradient_NSS\");\n"
"initsymbol(\"p_gradient_UIS\");\n"
"initsymbol(\"p_guano_UIS\");\n"
"initsymbol(\"p_gypsum_NSS\");\n"
"initsymbol(\"p_gypsumflower_NSS\");\n"
"initsymbol(\"p_helictite_UIS\");\n"
"initsymbol(\"p_ice_UIS\");\n"
"initsymbol(\"p_karren_UIS\");\n"
"initsymbol(\"p_lowend_NSS\");\n"
"initsymbol(\"p_lowend_UIS\");\n"
"initsymbol(\"p_moonmilk_UIS\");\n"
"initsymbol(\"p_narrowend_UIS\");\n"
"initsymbol(\"p_noequipment_SKBB\");\n"
"initsymbol(\"p_paleomaterial_UIS\");\n"
"initsymbol(\"p_pebbles_UIS\");\n"
"initsymbol(\"p_pillar_UIS\");\n"
"initsymbol(\"p_popcorn_UIS\");\n"
"initsymbol(\"p_raft_NSS\");\n"
"initsymbol(\"p_raftcone_NSS\");\n"
"initsymbol(\"p_rimstonedam_ASF\");\n"
"initsymbol(\"p_rimstonepool_ASF\");\n"
"initsymbol(\"p_root_ASF\");\n"
"initsymbol(\"p_rope_SKBB\");\n"
"initsymbol(\"p_ropeladder_SKBB\");\n"
"initsymbol(\"p_sand_UIS\");\n"
"initsymbol(\"p_scallop_UIS\");\n"
"initsymbol(\"p_sink_SKBB\");\n"
"initsymbol(\"p_snow_SKBB\");\n"
"initsymbol(\"p_sodastraw_UIS\");\n"
"initsymbol(\"p_spring_SKBB\");\n"
"initsymbol(\"p_stalactite_UIS\");\n"
"initsymbol(\"p_stalagmite_UIS\");\n"
"initsymbol(\"p_station_SKBB\");\n"
"initsymbol(\"p_station_fixed_ASF\");\n"
"initsymbol(\"p_station_natural_ASF\");\n"
"initsymbol(\"p_station_painted_SKBB\");\n"
"initsymbol(\"p_station_temporary_ASF\");\n"
"initsymbol(\"p_station_temporary_SKBB\");\n"
"initsymbol(\"p_steps_SKBB\");\n"
"initsymbol(\"p_traverse_SKBB\");\n"
"initsymbol(\"p_vegetabledebris_ASF\");\n"
"initsymbol(\"p_wallcalcite_UIS\");\n"
"initsymbol(\"p_water_UIS\");\n"
"initsymbol(\"p_waterflow_intermittent_UIS\");\n"
"initsymbol(\"p_waterflow_paleo_UIS\");\n"
"initsymbol(\"p_waterflow_permanent_UIS\");\n"
"initsymbol(\"l_arrow_SKBB\");\n"
"initsymbol(\"l_border_presumed_SKBB\");\n"
"initsymbol(\"l_border_temporary_SKBB\");\n"
"initsymbol(\"l_border_visible_SKBB\");\n"
"initsymbol(\"l_ceilingmeander_SKBB\");\n"
"initsymbol(\"l_ceilingstep_SKBB\");\n"
"initsymbol(\"l_chimney_UIS\");\n"
"initsymbol(\"l_contour_SKBB\");\n"
"initsymbol(\"l_contour_UIS\");\n"
"initsymbol(\"l_floormeander_SKBB\");\n"
"initsymbol(\"l_floorstep_UIS\");\n"
"initsymbol(\"l_flowstone_UIS\");\n"
"initsymbol(\"l_gradient_BCRA\");\n"
"initsymbol(\"l_gradient_UIS\");\n"
"initsymbol(\"l_mapconnection_SKBB\");\n"
"initsymbol(\"l_moonmilk_UIS\");\n"
"initsymbol(\"l_overhang_SKBB\");\n"
"initsymbol(\"l_pit_UIS\");\n"
"initsymbol(\"l_rockborder_UIS\");\n"
"initsymbol(\"l_rockedge_UIS\");\n"
"initsymbol(\"l_rope_SKBB\");\n"
"initsymbol(\"l_section_SKBB\");\n"
"initsymbol(\"l_slope_BCRA\");\n"
"initsymbol(\"l_slope_SKBB\");\n"
"initsymbol(\"l_survey_cave_SKBB\");\n"
"initsymbol(\"l_survey_cave_UIS\");\n"
"initsymbol(\"l_survey_surface_SKBB\");\n"
"initsymbol(\"l_wall_bedrock_UIS\");\n"
"initsymbol(\"l_wall_blocks_SKBB\");\n"
"initsymbol(\"l_wall_clay_SKBB\");\n"
"initsymbol(\"l_wall_debris_SKBB\");\n"
"initsymbol(\"l_wall_ice_SKBB\");\n"
"initsymbol(\"l_wall_pebbles_SKBB\");\n"
"initsymbol(\"l_wall_presumed_UIS\");\n"
"initsymbol(\"l_wall_sand_SKBB\");\n"
"initsymbol(\"l_wall_underlying_UIS\");\n"
"initsymbol(\"l_wall_unsurveyed_SKBB\");\n"
"initsymbol(\"l_waterflow_conjectural_SKBB\");\n"
"initsymbol(\"l_waterflow_intermittent_SKBB\");\n"
"initsymbol(\"l_waterflow_permanent_UIS\");\n"
"initsymbol(\"a_bedrock_SKBB\");\n"
"initsymbol(\"a_blocks_SKBB\");\n"
"initsymbol(\"a_clay_SKBB\");\n"
"initsymbol(\"a_debris_SKBB\");\n"
"initsymbol(\"a_debris_UIS\");\n"
"initsymbol(\"a_dimensions_SKBB\");\n"
"initsymbol(\"a_flowstone_ASF\");\n"
"initsymbol(\"a_ice_SKBB\");\n"
"initsymbol(\"a_moonmilk_SKBB\");\n"
"initsymbol(\"a_pebbles_SKBB\");\n"
"initsymbol(\"a_sand_UIS\");\n"
"initsymbol(\"a_snow_SKBB\");\n"
"initsymbol(\"a_sump_UIS\");\n"
"initsymbol(\"a_water_UIS\");\n"
;

#else

const char * thmpost_library = "input therion;";

#endif

